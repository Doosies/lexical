# Lexical 노드 가이드

이 문서는 Lexical의 핵심 개념인 노드(Node) 시스템에 대한 상세한 가이드입니다.

## 1. 노드 시스템 (Node System)

- **역할**: 노드는 `EditorState`를 구성하는 데이터 모델인 동시에, 에디터의 시각적 뷰를 형성하는 핵심 단위입니다.
- **기본 노드 종류**:
  - **`LexicalNode`**: 모든 노드의 최상위 기반이 되는 추상 클래스입니다.
  - **`RootNode`**: 에디터 전체를 감싸는 최상위 노드로, 단 하나만 존재하며 서브클래싱이 불가능합니다.
  - **`ElementNode`**: 다른 노드를 자식으로 가질 수 있는 노드입니다. (e.g., `ParagraphNode`, `HeadingNode`, `ListNode`)
  - **`TextNode`**: 실제 텍스트 콘텐츠를 담는 리프(leaf) 노드입니다.
  - **`DecoratorNode`**: React 컴포넌트와 같이 상호작용이 가능한 비-텍스트 요소를 렌더링하기 위한 특수 노드입니다.
  - **`LineBreakNode`**: `\n`(줄바꿈)을 일관되게 처리하기 위한 노드입니다.

### 1.1. 커스텀 노드 생성

- **확장**: `ElementNode`, `TextNode`, `DecoratorNode` 세 가지 기본 노드를 `extends`(상속)하여 프로젝트의 특정 요구사항에 맞는 새로운 유형의 노드를 정의할 수 있습니다. (e.g., `@mention`, `Image`, `Video`)
- **필수 구현**: 커스텀 노드는 다음과 같은 정적(static) 메서드와 인스턴스 메서드를 구현해야 합니다.
  - **`static getType()`**: 노드의 고유한 문자열 타입을 반환합니다. (e.g., 'custom-paragraph')
  - **`static clone(node)`**: 노드를 복제하는 로직을 정의합니다.
  - **`createDOM()`**: 노드에 해당하는 실제 DOM 요소를 생성합니다.
  - **`updateDOM()`**: 노드의 상태가 변경되었을 때 DOM을 어떻게 업데이트할지 정의합니다.
- **헬퍼 함수**: `$create[CustomNodeName]()`, `$is[CustomNodeName]()`과 같은 `$` 접두사가 붙은 헬퍼 함수를 함께 제공하여, 노드의 생성과 타입 검사를 쉽게 할 수 있도록 하는 것이 좋은 관례입니다.

### 1.2. 노드 속성 관리 (Properties)

- **안전한 접근**: 노드의 내부 속성을 직접 수정하는 것은 위험하며, 반드시 다음 두 메서드를 통해 접근해야 합니다.
  - **`getWritable()`**: 쓰기 가능한(mutable) 노드 인스턴스를 얻습니다. 속성을 **수정**하기 전에 반드시 호출해야 합니다.
  - **`getLatest()`**: 항상 최신 상태의 노드에서 속성을 **읽어옵니다.**
  - 이 두 메서드는 Lexical의 불변성을 유지하고 데이터 일관성을 보장하는 핵심 장치입니다.
- **`__` 접두사**: 노드의 내부 속성은 빌드 도구에 의한 코드 난독화(mangling)를 방지하기 위해 `__`(더블 언더스코어) 접두사를 사용하는 것이 관례입니다.

### 1.3. 데코레이터 노드 심화 (Decorator Nodes)

- **작동 방식**: `decorate` 메서드를 통해 렌더링할 React 컴포넌트를 반환합니다. Lexical은 이 컴포넌트를 React Portal을 사용하여 에디터의 DOM 트리 내 올바른 위치에 안전하게 렌더링합니다.
- **주요 특징**:
  - **읽기 전용 (Read-only)**: 기본적으로 사용자가 직접 내용을 수정할 수 없습니다.
  - **분리된 렌더링**: React 렌더링 로직이 Lexical의 핵심 업데이트 루프와 분리되어 있어 성능에 미치는 영향이 적습니다.

### 1.4. 노드 교체 (Node Replacement)

- **개념**: 에디터 설정(`initialConfig.nodes`)의 `replace` 옵션을 사용하여, Lexical의 핵심 노드(e.g., `ParagraphNode`)를 사용자가 직접 만든 커스텀 노드로 전면 교체하는 기능입니다.
- **사용 사례**: 프로젝트 전체에 걸쳐 기본 노드의 동작을 일관되게 변경하거나, 특정 기능을 모든 노드에 기본적으로 추가하고 싶을 때 사용됩니다.
- **`withKlass`의 중요성**: 이 옵션은 원본 노드를 대상으로 하는 내부 로직(노드 변환, 뮤테이션 리스너 등)이 교체된 커스텀 노드에도 동일하게 적용되도록 보장하여, 에디터 기능과의 완전한 통합을 가능하게 합니다.

### 1.5. 노드 순회 (Node Traversals with NodeCaret)

- **개념**: v0.25.0에 도입된 저수준 API로, 문서 트리를 순회하는 통합되고 효율적인 방법을 제공합니다.
- **핵심 요소**: 특정 지점을 `origin` (기준 노드), `direction` (방향), `type` (종류)의 조합으로 표현합니다.
- **불변성**: Caret 객체는 불변(immutable)이며, 문서 구조를 변경하는 메서드는 항상 새로운 Caret 객체를 반환하여 안정성을 높입니다.
- **주요 타입**: `SiblingCaret`, `ChildCaret`, `TextPointCaret`, `CaretRange` 등 다양한 타입을 통해 정교한 순회 로직을 구현할 수 있습니다.

### 1.6. NodeState API (동적 상태 주입)

- **개념 (v0.26.0+, 실험적)**: 노드 클래스를 직접 서브클래싱하고 수많은 보일러플레이트 코드를 작성하는 대신, 어떤 노드에든 동적으로 상태(state)를 추가하고 관리할 수 있게 해주는 효율적인 API입니다.
- **핵심 사용 사례**:
  - `createState`, `$getState`, `$setState` 함수를 사용하여 어떤 노드(심지어 `RootNode`)에든 동적으로 상태를 추가, 조회, 수정할 수 있습니다.
  - 문서 레벨의 메타데이터(e.g. 제목, 버전)를 `RootNode`에 저장하는 데 특히 유용합니다.
- **주요 특징**:
  - **자동 통합**: `NodeState`로 추가된 상태는 reconciliation, history, JSON 직렬화 과정에 자동으로 포함됩니다.
  - **효율성**: Copy-on-write 방식을 사용하며, 값이 기본값과 동일할 경우 직렬화에서 제외하여 공간 효율성을 높입니다.
  - **한계**: 아직 `importDOM`/`createDOM`과 직접적인 통합은 지원되지 않으며, 상태 변경을 감지하는 전용 리스너나 변환(transform) 기능이 없습니다.

### 1.7. 노드 복제 및 수정

- **세 가지 핵심 API:**
    1.  **`static clone(node)` (내부 API - 직접 호출 금지)**:
        - **역할**: Lexical의 상태 관리 시스템이 노드의 다음 버전을 만들기 위해 **내부적으로** 사용하는 정적 메소드입니다.
        - **구현**: 모든 커스텀 노드는 반드시 이 메소드를 구현해야 합니다. (`return new CustomNode(..., node.__key)`)
        - **규칙**: 개발자가 직접 이 메소드를 호출해서는 안됩니다.
    2.  **`$copyNode(node)` (공개 API - 복제용)**:
        - **역할**: 기존 노드의 완전한 복사본을 **새로운 키(key)** 와 함께 생성합니다.
        - **용도**: 노드를 복제하여 에디터의 다른 곳에 삽입하는 등, 순수한 '복사'가 필요할 때 사용합니다.
    3.  **`node.getWritable()` (공개 API - 수정용)**:
        - **역할**: 노드를 **수정**하기 전에, 해당 노드의 변경 가능한(mutable) 버전을 얻기 위해 사용합니다.
        - **구현 패턴**: 노드의 상태를 변경하는 모든 커스텀 인스턴스 메소드(e.g., `setData`) 내부에서, 다른 로직에 앞서 `const self = this.getWritable()`을 가장 먼저 호출해야 합니다. 이후의 모든 속성 변경은 `self`에 대해 이루어져야 합니다. 