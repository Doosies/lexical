# Tech Context

이 문서는 ECOUNT v5 프레임워크를 구성하는 주요 기술 스택, 라이브러리, 개발 컨벤션 및 빌드 시스템에 대해 설명합니다.

## 프로젝트 구조 및 아키텍처

### 1. 물리적 구조 (폴더)

-   **`ecount.nextv5`**: `.ts` 소스 코드가 위치하는 워크스페이스입니다.
-   **`ecountv5`**: 빌드 후 `.js` 산출물이 위치하는 폴더입니다. 소스와 산출물을 분리하여, 개발자가 전체 빌드 없이 최신 산출물을 내려받아 개발을 시작할 수 있게 합니다.
-   **`@env`**: 환경 설정 파일들이 위치하며, 빌드 시 `ecountv5/Env` 폴더로 복사됩니다.

### 2. 논리적 구조 (계층)

-   **계층 구조:** `Solution` > `Project` > `Module` > `Micromodule` 순서의 계층을 가집니다.
-   **프로젝트 (Projects):** 4개의 핵심 프로젝트가 있으며, 상위 프로젝트에서 하위 프로젝트를 참조할 수 없는 엄격한 단방향 의존성을 가집니다.
    1.  `01.ecount.fundamental`: 프레임워크의 가장 기본 타입(`$$code`), 데이터 구조(`DMC`) 정의. 플랫폼에 종속되지 않음(`Platform less`).
    2.  `02.ecount.infrastructure`: 상위 레이어를 위한 인터페이스, 추상 구현체(Builder, Resolver), 데코레이터 제공.
    3.  `03.ecount.usecase`: 실제 업무(비즈니스) 로직을 담당. (재고, 회계 등)
    4.  `04.ecount.application`: UI 페이지(Page.tsx), 네비게이션 정책 등 최상위 애플리케이션 레벨을 담당.
-   **참조 단위:** 모든 소스 코드의 참조는 가장 작은 단위인 **`Micromodule`** 단위로 이루어집니다.
-   **설정 파일:** 신규 프로젝트/모듈/마이크로 모듈은 각 프로젝트의 `project.json` 파일에 등록해야 합니다.

### 3. 서버/클라이언트 아키텍처

-   **서버:** .NET Core 기반의 Kestrel 웹 서버 위에서 **Velox**라는 자체 JavaScript 인터프리터를 실행하여 TypeScript로 작성된 서버 로직을 구동합니다.
-   **클라이언트:** **React**와 **TypeScript**를 기반으로 하는 SPA(Single Page Application)입니다.

---

## 데이터 접근 및 상태 관리

-   **데이터 접근 (서버):**
    -   **Dac (Data Access Component):** `DacCommandBuilder`를 통해 실행되며, ESQL문을 사용하여 **데이터베이스**에 접근하는 로직을 캡슐화합니다.
    -   **Rac (Remote Access Component):** `RacCommandBuilder`를 통해 실행되며, 외부 HTTP API를 호출하여 **원격 서버**와 통신하는 로직을 캡슐화합니다.
-   **상태 관리 (클라이언트):**
    -   **Zustand:** `VMC(ViewModelStateContainer)`의 기반이 되는 경량 상태 관리 라이브러리입니다.
    -   **Immer:** `Zustand`와 함께 사용되어 불변성 유지를 돕습니다.
    -   **`useSyncExternalStore`:** 외부 스토어(VMC)의 변경을 구독하여 효율적인 리렌더링을 구현하는 React 18 훅입니다.
    -   **`mutative`**: `Zustand`와 함께 사용되어 불변성(immutability)을 유지하면서도 마치 직접 객체를 수정하는 것처럼 편리하게 상태를 업데이트할 수 있도록 돕습니다. Immer와 유사한 역할을 수행합니다.

---

## 빌드 시스템

-   **주요 도구:**
    -   **`tsc` (TypeScript Compiler):** 타입 체크 및 TS -> JS 컴파일을 수행합니다. (주요 성능 병목)
    -   **`rollup.js`:** `swc` 플러그인을 사용하여 컴파일된 파일들을 UMD 형식으로 번들링합니다.
-   **프로세스:** `planner`가 생성한 `MasterPlan`에 따라 `tsc`와 `rollup`을 병렬 프로세스로 실행하여 빌드를 수행합니다.

-   **빌드 자동화:** VSCode의 **`ECount Developer Hub`** 확장을 통해 빌드 및 배포 관리가 이루어집니다. 소스 브랜치와 산출물 브랜치를 연결하여 빌드를 실행할 수 있습니다.

-   **Identifier 캐싱 정책:** 빌드 속도 향상을 위해 Identifier 정보는 캐싱되며, 플랫폼별로 동작 방식에 차이가 있습니다.
    -   **Browser:** `Program`, `Feature` 등의 Identifier와 그 구현체는 함께 빌드되어 `ecount.builder.map` 하위의 json 파일에 캐싱됩니다. 변경 사항을 반영하려면 구현부를 빌드해야 합니다.
    -   **Server:** Identifier만 빌드해도 변경 사항이 즉시 반영됩니다. 서버는 런타임에 모듈을 즉시 호출하므로 구현부를 다시 빌드할 필요가 없습니다.
    -   **ActionIdentifier:** 별도의 json 캐시를 사용하지 않습니다. `ActionIdentifier`를 사용하는 브라우저 측 코드를 빌드해야 변경 사항이 반영됩니다.

### 런타임 리소스 로딩

-   **동적 모듈 로딩**: 프레임워크는 `$ECount.requireAsync` 유틸리티를 사용하여 런타임에 필요한 JS 모듈(페이지 컴포넌트, UserAction 번들 등)을 동적으로 로드합니다. 이는 초기 로딩 시간을 줄이고, 필요한 시점에만 리소스를 다운로드하는 역할을 합니다.
-   **전역 객체 활용**: 동적으로 로드된 `UserAction` 번들 등은 `globalThis` 전역 객체에 자신을 등록합니다. 이후 `ActionManager`와 같은 관리자는 전역 객체에 등록된 클래스를 찾아 인스턴스화하여 사용합니다.

---

## 캐시 전략

-   **다층적 캐시 구조:** 프레임워크는 성능 최적화를 위해 다층적인 캐시 전략을 사용합니다. 데이터 조회 시 `Context 캐시` > `SSDB 캐시` > `원본 DB` 순서로 확인하며, 상위 캐시에 없으면 하위에서 가져와 채워 넣는 방식으로 동작합니다.
    -   **Context 캐시:** API 호출(Action 실행) 동안만 유효한 메모리 기반 캐시. 가장 빠르지만 생명주기가 가장 짧습니다.
    -   **SSDB 캐시:** LevelDB 기반의 Key-Value 저장소. 여러 웹 서버가 공유하며, 15일 주기로 초기화됩니다.
    -   **브라우저 캐시:** 브라우저단에서 특정 API 응답을 캐싱합니다.
-   **동기화:** 원본 데이터가 변경되면 관련된 모든 캐시(Context, SSDB 등)를 무력화하여 데이터 정합성을 유지합니다.

---

## 테스트 전략: Storybook 기반 E2E 테스트

-   **테스트 분리:** 테스트는 2가지 유형으로 분리되어 관리됩니다.

    1.  **데이터 타입 기반 테스트 (공통):** `data_type` + `view_type`을 기준으로 하는 공통 속성(Attribute) 테스트입니다. FE 부문에서 **Storybook**을 통해 관리합니다.
    2.  **업무 기반 테스트 (비즈니스):** `menu_type`, `action_mode` 등 특정 비즈니스 로직에 종속적인 테스트입니다. 각 업무 개발자가 작성합니다.

-   **Storybook 테스트 자동화 흐름:**
    1.  **`Attribute Story` 정의:** 개발자는 모든 `Attribute`에 대해 다양한 시나리오(기본, 예외 등)를 포함하는 테스트용 Mock 데이터를 `*.story.ts` 파일에 정의합니다.
    2.  **`DataType StoryBook` 등록:** 특정 데이터 타입이 가질 수 있는 모든 `Attribute`들을 `*.story.ui.tsx` 파일에 등록합니다.
    3.  **자동화된 테스트 실행:** Storybook 빌드 시, 등록된 정보를 기반으로 E2E 테스트가 자동으로 수행됩니다. 이 구조는 프레임워크의 핵심인 `Attribute` 단위의 독립적인 테스트를 가능하게 합니다.

---

## 버전 관리 및 워크플로우

-   **소스/산출물 분리:** 소스 코드(`ecount.nextv5`)와 빌드 산출물(`ecountv5`)은 별도의 Git 저장소 또는 브랜치로 관리됩니다.
-   **중앙 브랜치:** `ecount/master-nol4` 브랜치가 중앙 통합 브랜치 역할을 합니다.
-   **일일 작업 브랜치:** 개발자들은 매일 `ecount/master-nol4`로부터 그날의 날짜가 포함된 새로운 작업 브랜치(예: `EDT/A25_00294/20250207`)를 생성하여 작업을 진행합니다.
-   **커밋 압축:** 작업일 종료 시, 해당일의 모든 커밋은 `git reset --soft`와 `cherry-pick`을 통해 단일 커밋으로 압축되어 중앙 브랜치에 병합될 준비를 합니다. 이는 깔끔한 커밋 히스토리를 유지하기 위함입니다.

---

## 주요 개발 컨벤션 및 원칙

-   **계층 간 의존성:** 상위 프로젝트는 하위 프로젝트를 참조할 수 없습니다. (예: `03.usecase`는 `01.fundamental`을 참조할 수 있지만, 그 반대는 불가)

-   **`@abstraction` vs `@implement`:** Usecase 모듈의 export는 두 개의 특별한 마이크로 모듈을 통해 제어됩니다.

    -   **`@abstraction`**: 외부에서 **호출만** 필요한 경우 사용합니다. `Identifier`와 `interface`만 노출하여 외부 모듈과의 결합도를 최소화합니다. (주로 `Program` 명세)
    -   **`@implement`**: 외부에서 **`new` 키워드로 생성하거나 상속**해야 하는 경우 사용합니다. 실제 `class` 구현체를 노출합니다. (주로 `Feature` 구현체)

-   **DI 및 IoC 패턴 (Builder 사용):**

    -   `Program`, `Feature` 등의 핵심 실행 단위는 `new` 키워드로 직접 생성하지 않습니다.
    -   대신 `ProgramBuilder`, `FeatureBuilder` 등을 통해 **`Identifier`를 키로 사용하여** 해당 구현체를 생성하고 주입받습니다.
    -   이를 통해 테스트 시 Mock 객체를 쉽게 주입하거나, 런타임에 특정 `Feature`의 구현을 교체하는 등 유연한 아키텍처를 구현합니다.

-   **데코레이터 기반 연결:** `@page_impl`, `@program_impl`, `@default_feature` 등의 데코레이터를 사용하여 명세(Identifier)와 구현(Class)을 연결합니다.

---

## 주요 용어 정리

-   **전표:** 판매, 구매 등 하나의 거래를 기록하고 관리하는 문서 단위.
-   **조회 vs 현황:** **조회**는 '전표' 단위로 데이터를 보여주는 메뉴이며, **현황**은 전표 내의 '개별 라인(품목)' 단위로 데이터를 집계하여 보여주는 메뉴입니다.
-   **기초코드:** 전표를 작성하기 위해 기본이 되는 데이터 (e.g., 거래처, 품목, 창고).
-   **nol4:** L4 로드밸런서에 연결되지 않은, 개발용 서버.
-   **table_model:** DB 테이블과 1:1로 매핑되는 데이터 객체. 로직 처리에 사용되는 `DataModel`은 DB 저장 전에 `table_model`로 변환됩니다.
