# 📄 0. 회의 기본 정보  
- **회의 ID**: MEET-20250808-001
- **자동 분류**: 개발, 아키텍처
- **회의 시간**: 2025-08-08 09:53 ~ 11:41
- **한 줄 요약 제목**: Flexion 아키텍처 및 컴포넌트 개발 방향성 논의
- **회의 성격**: 개발 리뷰
- **원본 파일명 및 경로**: `.cursor/meeting/original/250808_0953(flexion).txt`
- **회의록 작성일시**: 2025-08-08 11:50

# 👥 1. 참석자  
- 남대관, 김남훈, 김진경, 조현오, 송민형, 최승현, 서준석

# 📌 2. 회의 주제 요약  
Flexion 프로젝트의 현재 개발 현황을 공유하고, 아키텍처, 컴포넌트 설계, 네이밍 컨벤션 등 주요 개발 원칙을 통일하기 위해 논의했습니다. 특히 5.0 프레임워크와의 의존성을 제거하고, Flexion을 독립적이고 재사용 가능한 UI 프레임워크로 구축하기 위한 방향성을 설정하는 데 중점을 두었습니다. 또한, 컴포넌트 개발 가이드와 개발 환경 구축 현황을 점검하고, 향후 개발자 투입 시 필요한 작업과 역할을 분배했습니다.

# 🧷 3. 주요 키워드  
Flexion, AST, Node, State, 데이터 타입, 5.0 의존성, 컴포넌트, 플러그인, 커맨드, 아키텍처, 네이밍 컨벤션, ERP, UI, 프로바이더, 그리드, 테이블

# 📎 4. 주요 내용 요약  
### **주제 1: 5.0 프레임워크 의존성 제거 및 개념 분리**
- **문제 제기**: 컴포넌트 개발 시 `Renderer Attributes` 등 5.0 프레임워크의 개념과 데이터 구조를 그대로 가져와 사용하는 것은 Flexion의 독립성을 해치고, 향후 개발에 혼란을 야기함.
- **논의 과정**:
  - `의견1`: 기존 컴포넌트를 빠르게 이관하기 위해 5.0의 타입을 가져왔다고 설명.
  - `의견2`: 5.0의 개념을 머릿속에서 지우고, Flexion 컴포넌트가 순수하게 제공해야 할 기능과 요구사항부터 재정의해야 한다고 강조. 기획적 요구사항은 유지하되, 데이터 구조와 용어는 Flexion에 맞게 재설계해야 함을 역설.
- **최종 결론**: 5.0과 관련된 모든 타입, 용어, 데이터 구조를 Flexion 프로젝트에서 제거하고, Flexion 고유의 인터페이스(AST Node 형)를 우선적으로 설계하는 원칙에 합의함.

### **주제 2: 패키지 구조 및 컴포넌트 위치 재정의**
- **문제 제기**: `Date` 컴포넌트가 `flexion-erp`에 있고, 관련 `Node`는 `flexion-ui`에 있는 등 패키지 간 역할 분리가 모호하며, 특히 'ERP'라는 용어가 5.0 종속적인 서비스로 오해될 소지가 있음.
- **논의 과정**:
  - `의견1`: ERP 서비스(휴일 정보 등)와의 연동 때문에 `flexion-erp`에 컴포넌트를 배치했다고 설명.
  - `의견2`: 컴포넌트 자체는 ERP에 종속되지 않는 중립적인 UI 요소여야 하며, ERP 관련 로직은 외부에서 주입되는 '플러그인'으로 처리해야 한다고 설명. `ECDate`가 아닌 범용 `Date` 컴포넌트가 `flexion-ui`에 포함되는 것이 맞다고 주장.
- **최종 결론**: `flexion-erp`는 5.0 시스템과의 브릿지 역할만 수행하고, 핵심 UI 컴포넌트와 노드는 모두 `flexion-ui` 패키지로 통합하기로 결정. 컴포넌트는 특정 서비스(ERP)에 종속되지 않도록 중립적으로 설계해야 함.

### **주제 3: 네이밍 및 용어 통일**
- **문제 제기**: 노드, 상태, 데이터 타입 등의 네이밍 컨벤션이 개발자마다 달라 혼선이 발생하고 있음. 특히 `data`와 `state`의 개념이 모호하게 사용됨.
- **논의 과정**:
  - **(파일/클래스명)**: `PascalCase`로 통일 (예: `FlexionDateNode.tsx`).
  - **(플랫폼 접두사)**: `React` 등 특정 플랫폼에 종속적인 구현체(컴포넌트)에는 접두사를 붙일 수 있으나, 플랫폼 중립적인 노드(Node)나 인터페이스에는 붙이지 않기로 함.
  - **(data vs value)**: 컴포넌트가 가지는 원시 값(primitive value)을 지칭하는 용어를 `data`에서 `value`로 변경하여 명확성을 높이기로 함. `state`는 렌더링에 필요한 부가적인 상태 정보로 정의.
- **최종 결론**: 위 네이밍 컨벤션을 공식 가이드로 정하고, 전체 프로젝트에 일관되게 적용하기로 함.

### **주제 4: 개발 방법론: 커맨드 패턴 도입**
- **문제 제기**: 현재 컴포넌트가 외부에서 기능(Props)을 주입받아 내부에서 로직을 처리하는 방식은 5.0의 레거시 설계이며, Lexical의 철학과 맞지 않음.
- **논의 과정**:
  - `의견1`: 컴포넌트는 오직 `value`와 `state`를 받아 렌더링하고, 사용자 인터랙션이 발생하면 외부로 '커맨드(Command)'를 디스패치하는 역할만 수행해야 한다고 강조.
  - 실제 비즈니스 로직(휴일 정보 조회, 유효성 검사 등)은 이 커맨드를 수신하는 '플러그인(Plugin)'이 처리해야 한다고 설명. 이를 통해 컴포넌트와 비즈니스 로직의 결합도를 낮출 수 있음.
- **최종 결론**: 모든 컴포넌트 개발은 커맨드-플러그인 아키텍처를 따라야 함. 개발자는 'Flexion AST Node 형 정의'와 '컴포넌트가 디스패치할 커맨드 목록 정의'를 최우선으로 설계해야 함.

# 📝 5. 액션 아이템 (해야 할 일)
- **담당자**: 남대관
  - **할일**:
    1.  'Normalized Definition' 표준 스펙을 월요일까지 정리 및 공유.

- **담당자**: 김진경, 서준석, 송민형
  - **할일**:
    1.  입력 그리드 관련 컴포넌트 3개를 나누어 개발 시작.
    2.  개발 시 금일 논의된 원칙(AST 형 우선 설계, 커맨드 패턴, 5.0 의존성 제거)을 반드시 준수.

- **담당자**: 최승현
  - **할일**:
    1.  기존에 작업하던 컴포넌트들을 새로운 가이드에 맞게 재설계 (AST 형, 커맨드 목록 정의).
    2.  `ERP Service`를 `Data Model Service`와 `User Action Service`로 분리하고, 관련 프로바이더 주입 구조 정리.

- **담당자**: 김진경
  - **할일**:
    1.  현재 `flexion-table` 패키지에 있는 네이밍을 `table`에서 `grid`로 변경하여 용어 혼선 방지.

- **담당자**: 김남훈
  - **할일**:
    1.  논의된 네이밍 컨벤션과 개발 가이드를 문서화하고 팀에 공유.
    2.  신규 노드/컴포넌트/플러그인 생성을 위한 보일러플레이트 템플릿 스크립트 작성 검토.

# 📖 6. 단락별 요약

00:15~08:14
**데이트 컴포넌트 개발 가이드**
- 컴포넌트 개발 환경, 플러그인/컴포넌트 개발 가이드 3종 구축 완료.
- 개발자 투입 시 플레이그라운드에서 데이트 컴포넌트 렌더링 및 동적 변경 가능.
- 투입된 개발자는 노드의 데이터 타입(data, node)을 먼저 정의하고 이해해야 함.

08:57~10:26
**데이터 컴포넌트의 기능**
- 기획적 요구사항은 유지하되, 5.0의 데이터 구조를 그대로 가져올 필요는 없음.
- 데이터 컴포넌트가 제공해야 할 순수한 기능 목록을 먼저 정리하는 것이 중요.

10:31~12:44
**AST 형의 인터페이스**
- 기획 요구사항은 별도로 정리.
- 개발 시에는 정확한 용어, 형식, 위치가 중요.
- 모든 컴포넌트의 첫 번째 인터페이스는 반드시 AST 노드(Node)의 형(Type)으로 제공되어야 함.

13:21~15:31
**데이터 컴포넌트의 설계**
- 컴포넌트는 어떤 커맨드(Command)를 발생시킬지, 각 커맨드에 어떤 데이터를 담을지를 정의해야 함.
- 현재 설계는 미흡하므로, 구조 설계부터 다시 진행해야 함.

15:49~21:51
**플렉션 UI의 독립성**
- 플렉션 UI(Flexion-UI)는 ERP와 무관한 독립적인 라이브러리임.

22:13~27:36
**플러그인의 개념**
- 휴일 정보 같은 외부 데이터는 플러그인(Plugin)을 통해 외부에서 주입되어야 함.
- 플러그인은 우리가 설계하며, 필요한 경우 내부 로직을 별도 서비스로 분리할 수 있음.
- 플러그인 개념을 모호하게 사용하면 흐름 제어를 포기하는 것과 같음.

27:37~29:02
**네이밍 컨벤션: 리액트 접두사**
- 파일명, 클래스명에 '리액트(React)' 같은 특정 플랫폼 용어는 사용하지 않기로 했었으나, 재논의 결과 필요시 사용하기로 함.

29:21~31:57
**컴포넌트의 관점: Value**
- 데이터 모델의 원시 데이터는 `value`로 통일.
- 컴포넌트의 props는 `value`를 받도록 하여, 컴포넌트가 데이터 모델의 값이라는 것을 명시함.

31:58~35:59
**데이터 타입 용어 변경**
- 기존에 `data type`이라 부르던 것을 `value type`으로 변경.
- 단, 이로 인한 커뮤니케이션 오류 발생 가능성을 인지해야 함.

36:30~39:19
**프로바이더(Provider)의 의미**
- 버튼 노드 생성 시 필요한 상태(state)를 넣어주는 역할을 함.
- 프로바이더는 데이터 타입의 식별자(ID) 또는 데이터 자체를 의미.

39:20~44:12
**데이터 타입**
- 5.0의 데이터 타입은 참고만 할 뿐, 의미 부여 없이 컴포넌트의 본질(예: 버튼)에 맞게 새로 정의.
- 플랫폼 타입(platform type)에 반드시 포함되어야 함.
- 인터페이스명은 명확하게 정의해야 함.

44:15~45:58
**노드 타입의 종류**
- 노드 타입(Node Type)은 뷰 타입(View Type)에 따라 달라질 수 있음.
- 데이터 타입이 가진 명칭과 동일하게 사용하는 것을 원칙으로 함.

46:13~46:57
**노드명과 파일명**
- 플랫폼(리액트 등)에 의존적인 컴포넌트와 달리, 노드(Node)는 플랫폼 중립적이므로 파일명/클래스명에 플랫폼 접두사가 불필요.

47:35~52:11
**데코레이터의 개념**
- 데코레이터 노드(DecoratorNode)는 특정 리액트 컴포넌트를 렌더링하라는 약속(protocol)과 같음.

52:12~58:05
**리액트를 뺀 이유와 그리드/테이블**
- 특정 플랫폼(리액트) 종속성을 제거하여 언제든 교체 가능하게 하기 위함.
- `grid`와 `table` 용어 혼ใช้. 단순 네이밍 문제라면 `grid`로 통일하고, 모듈 수준의 분리가 필요하다면 `table`을 유지.

58:28~01:02:00
**보일러플레이트 제작**
- 커서(Cursor)를 이용해 노드/컴포넌트/플러그인 생성을 위한 템플릿(보일러플레이트) 스크립트를 만들 수 있음.

01:02:08~01:03:32
**컴포넌트 이전 계획**
- 4주 안에 모든 컴포넌트를 그대로 가져오려던 계획은 불가능.
- 복잡한 컴파운드 로직을 고려해야 함.

01:03:52~01:07:01
**ERP 서비스 패키지**
- `ERP 서비스`는 `프레임워크 서비스`라는 이름으로 플렉션에 포함될 예정.
- 뷰 모드(View Mode)에 따라 리포트해야 하는 요구사항 때문에 다시 포함됨.

01:07:30~01:11:41
**ERP 서비스 콜**
- 플러그인 단에서 이벤트(예: 버튼 클릭)가 발생하면, 커맨드에 액션 타입(예: `search_button`)을 담아 ERP 서비스를 호출.
- `search_button` 같은 명시적인 커맨드가 필요.

01:11:49~01:16:22
**DMC의 개념**
- `getValue`와 같은 인터페이스를 통해 로직을 처리.
- 서비스가 DMC를 인지하고, 서비스를 통해 값을 보여줌.
- `setValue`는 특정 시점을 호출하는 개념으로, 여기서는 부적합.

01:16:30~01:19:59
**어트리뷰트 패치**
- `Attribute`라는 용어 사용 가능. `AttributeResolver` 또는 `AttributeFetcher` 같은 역할.
- 5.0에서 쓰이는 `Format`, `Validator` 등은 우리만 쓸 거면 그대로 가져와도 무방.
- 프로바이더는 페이지 플러그인 레벨에서 제공해야 함.

01:20:07~01:24:59
**유저 액션 서비스**
- `User Action Service`와 `Data Model Service` 두 개로 분리.
- `User Action`과 `Data Model`이라는 용어는 유지.
- 플러그인/노드 프로바이더도 커먼(common)에 정의하고 메뉴별로 주입 가능하도록 설계.

01:25:01~01:27:38
**외부 프레임워크 의존성 제거**
- 외부 프레임워크에 의존하지 않도록, 우리 쪽 인프라를 직접 수정하는 것을 금지.
- 구현은 외부에서 하되, 등록(registry)은 우리 쪽에서 관리.
- 노드 프로바이더는 노드 매니저(NodeManager) 피처에서 호출.

01:28:19~01:29:48
**코드 플러그인**
- 코드 플러그인을 내부에 넣어 정리 필요.
- 메뉴별 노드 생성은 후순위, 가이드 생성으로 우선 대체.
- 코드 플러그인은 기본(default)으로 만들지만, 메뉴별로도 생성 가능.

01:30:14~01:31:26
**플러그인의 종류**
- 플러그인은 3가지로 분리:
  1.  **디폴트 플러그인**: 노드와 무관하게 항상 활성화.
  2.  **노드 플러그인**: 특정 노드가 추가될 때 리졸버를 통해 삽입.
  3.  **(메뉴별 플러그인)**

01:31:28~01:40:30
**5.0 버전의 UI 설계**
- `UserAction`과 `Payload`를 서비스의 것만 호출하도록 로직 구현.
- 기능 담당자는 5.0을 직접 분석하여, 특정 기능에 어떤 플러그인과 커맨드가 필요한지 설계해야 함.

01:40:49~01:47:21
**뷰 모델 어트리뷰트**
- 뷰 모델(View Model)에서 생성된 어트리뷰트(Attribute)를 가져와 AST 노드에 편입시켜야 함.
