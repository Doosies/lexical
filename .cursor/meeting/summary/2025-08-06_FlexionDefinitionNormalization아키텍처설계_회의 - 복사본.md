# 📄 0. 회의 기본 정보  
- **회의 ID**: MEET-20250806-001  
- **자동 분류**: 개발, 아키텍처  
- **회의 시간**: 2025-08-06 13:38 ~ 14:53  
- **한 줄 요약 제목**: Flexion Definition Normalization 아키텍처 설계 논의  
- **회의 성격**: 아키텍처 설계  
- **원본 파일명 및 경로**: .cursor/meeting/original/250806_1538(flexion).txt  
- **회의록 작성일시**: 2025-08-06 15:31

# 👥 1. 참석자  
- 남대관, 김남훈, 김진경, 조현오, 송민형, 최승현

# 📌 2. 회의 주제 요약  
- 기존 `i-Setup` 또는 `Template` 같은 다양한 외부 데이터 소스를 각 프레임워크에서 직접 `AST(추상 구문 트리)`로 변환하는 방식은, 프레임워크가 변경될 때마다 동일한 변환 로직을 중복 개발해야 하는 문제를 야기합니다. 본 회의에서는 이 문제를 해결하기 위해, 모든 외부 데이터를 Flexion이 이해할 수 있는 표준화된 중간 표현(`Normalized Definition`)으로 변환하는 새로운 아키텍처 계층의 도입을 제안하고, 그 구체적인 설계 방안을 논의했습니다.

# 🧷 3. 주요 키워드  
- Definition Normalization, 정규화, AST, Flexion Node, i-Setup, Template, 데이터 모델, 레이아웃, 플러그인, VMC, DMC, P-Executor

# 📎 4. 주요 내용 요약  
### **주제 1: `Definition Normalization` 계층 도입**
- **문제 제기 (참석자 2)**: 현재 `i-Setup`을 `AST`로 변환하는 로직이 모두 외부에 있어, `Template` 등 다른 데이터 소스를 지원할 때마다 정렬, 합계, 플러그인 등록 등의 로직을 프레임워크별로 중복 구현해야 합니다. 이는 제어의 분산을 야기하고 유지보수를 어렵게 만듭니다.
- **논의 과정**:
  - `참석자 2`는 이 문제를 해결하기 위해, 외부 데이터와 `AST` 변환 사이에 `Normalized Definition`이라는 표준화된 중간 계층을 두자고 제안했습니다. 이 계층의 목표는 다양한 입력(i-Setup, Template 등)을 `Flexion Node`라는 표준화된 중간 산출물로 1차 변환하는 것입니다.
  - 이를 통해 Flexion의 핵심 로직은 오직 `Normalized Definition`만을 상대하게 되어, 외부 프레임워크의 변화로부터 독립성을 확보할 수 있습니다.
  - `참석자 1`이 데이터 변환 단계 추가로 인한 성능 저하를 우려했으나, `참석자 2`는 이 단계에서는 대용량 데이터 모델 자체가 아닌 항목, 배치 등 메타 정보만을 다루기 때문에 성능 영향은 미미할 것이라고 설명했습니다.
- **최종 결론**: `Definition Normalization` 계층을 도입하는 방향으로 설계 진행에 동의했습니다.

### **주제 2: 플러그인 및 속성 처리 방식 변경**
- **문제 제기 (참석자 2)**: 현재는 외부 프레임워크(e.g., 5.0)가 특정 기능(e.g., 체크박스)에 어떤 플러그인이 필요한지 알아야 하고 직접 등록해줘야 합니다. 이는 Flexion 내부의 구현(e.g., 플러그인 A -> B로 변경)이 외부에 영향을 주는 강한 결합(tight coupling) 문제를 만듭니다.
- **논의 과정**:
  - `참석자 2`는 `Flexion Node`에는 기능 사용 여부에 대한 메타 정보(e.g., `use-checkbox: true`)만 담고, 실제 어떤 플러그인을 로드하고 실행할지에 대한 결정은 Flexion 내부에서 하자고 제안했습니다.
  - 더 나아가 `Validator`, `Formatter`와 같은 복잡한 속성들은 `Normalized Definition`에 모두 담기보다, `P-Executor`(Attribute Resolver)라는 모듈을 통해 런타임에 동적으로 조회하는 방식을 제안했습니다. 이는 데이터 구조를 단순화하고, 캐스케이딩 되는 복잡한 속성 규칙(양식 -> SC -> 공통)을 효율적으로 처리하기 위함입니다.
- **최종 결론**: 플러그인과 복잡 속성의 실제 구현 로직은 Flexion 내부로 숨기고, 외부에서는 메타 정보만 전달하는 방식으로 변경하는 것에 동의했습니다.

### **주제 3: 기존 인터페이스(VMC/DMC)와의 호환성 유지**
- **문제 제기 (참석자 3)**: 새로운 아키텍처가 도입되면 기존의 수많은 유저 액션에서 사용하는 `VMC`나 `DMC`는 어떻게 처리해야 하는지 질문했습니다.
- **논의 과정**:
  - `참석자 2`는 기존 유저 액션의 수정을 최소화하기 위해, `VMC`와 `DMC`의 인터페이스는 그대로 유지한다고 설명했습니다.
  - 다만, 내부적으로는 기존의 뷰 모델을 직접 제어하는 대신, Flexion의 `AST Node`를 찾아 상태를 변경하는 방식으로 구현이 변경될 것이라고 답변했습니다.
- **최종 결론**: 기존 `VMC`/`DMC` 인터페이스는 유지하되, 내부 구현은 Flexion 아키텍처에 맞게 재작성하는 것으로 결정했습니다.

# 📝 5. 액션 아이템 (해야 할 일)
- 담당자: 전체팀
  - 할일:  
    1. `Normalized Definition`의 구체적인 타입(인터페이스) 확정
    2. `VMC`/`DMC`의 `setPropState` 호출 시, `AST Node`와 상태를 동기화하는 로직 개발
    3. 최종 AST 노드 형식 확정
  - 마감기한: 없음

# 📖 6. 단락별 요약
00:04~02:07
**도입 및 문제 제기**
- `뷰 모델 제너레이터`가 외부에 있는 현재 구조의 문제점을 공유하며 논의 시작.
- 기존에는 `i-Setup`에서 `AST`로 직접 변환했으나, 이 방식은 `Template` 등 다른 데이터 소스를 지원할 때 로직 중복 문제가 발생함.
- 핵심 목표는 **외부 정의 구조를 정규화(`Definition Normalization`)**하여 Flexion 내부로 가져오는 것.

02:07~07:06
**`Definition Normalization` 개념 설명**
- 외부 데이터(`i-Setup`, `Template` 등)와 `AST` 생성 사이에 **표준화된 중간 표현 계층(`Normalized Definition`)**을 도입.
- 외부 데이터는 **항목, 배치, 데이터 모델** 세 가지 유형으로 분류되며, 어떤 조합으로든 들어올 수 있음을 가정.
- 이 중간 계층은 다양한 데이터 소스를 **`Flexion Node`**라는 표준 형태로 1차 변환하여, Flexion의 핵심 로직이 외부 변화에 종속되지 않도록 함.

07:06~10:38
**`Flexion Node`와 플러그인 처리**
- `Flexion Node`는 `AST Node`와 유사한 형태로, `nodeId`, `dataType`, `valueKey`, `state` 등의 정보를 가짐.
- 기존에는 외부에서 `팝업 기능`이 필요하면 해당 플러그인을 직접 등록했지만, 앞으로는 `Flexion Node`에 **기능 사용 여부에 대한 메타 정보**만 담음.
- 어떤 플러그인을 로드할지는 **Flexion 내부에서 판단**하여 결합도를 낮춤.

10:38~15:08
**아키텍처 전체 흐름**
- 모든 외부 데이터는 `Normalized Definition`을 거쳐야만 Flexion 프레임워크와 상호작용 가능.
- **1단계: Normalization**: 항목 정보(`Flexion Node`)와 배치 정보(`Layout Definition`)를 표준화. (데이터 모델은 관여 X, 성능 영향 미미)
- **2단계: Composition**: 표준화된 항목/배치 정보와 실제 데이터 모델을 조합하여 최종 `AST Node`를 생성.

15:08~19:31
**개발 방향 및 협업**
- `Definition Normalization` 관련 개발은 기존 컴포넌트 개발과 병행.
- 기존 `뷰 모델 제너레이터`와 플러그인 로직은 일단 유지하되, 점진적으로 새로운 아키텍처로 이전.
- `인쇄`와 `템플릿`에서 사용되던 기존 룰들을 새로운 구조에 맞게 통합해야 하는 복잡한 작업이 남아있음.

19:31~26:05
**캐싱 및 기존 로직 처리**
- 데이터 모델이 포함되는 `Composition` 단계에서 캐싱이 필요할 수 있으나, 일단 보류.
- 기존 `뷰 모델 제너레이터`(AST Finalization)는 새로운 아키텍처가 완성되면 **폐기**될 예정.
- 페이지별 합계/소계 로직은 외부(`5.0`)가 아닌, **Flexion 내부에서 처리**하는 것으로 변경.

26:05~30:04
**Flexion 아키텍처 레이어**
- **App Level (e.g., 5.0)**: `i-Setup`, `Template` 등 원본 데이터.
- **Flexion ERP**: App Level 데이터를 `Normalized Definition`으로 변환하는 **Normalizer**를 주입받는 계층. 합계/소계 등 비즈니스 로직 포함.
- **Flexion Core**: `AST Node`를 직접 다루는 순수 Lexical 계층.

30:04~39:06
**플러그인 및 속성(Attribute) 처리 심화**
- 플러그인 로딩은 **Flexion 내부에서 결정**.
- `Validator`, `Formatter` 등 복잡한 속성은 `Normalized Definition`에 모두 담지 않고, **런타임에 동적으로 조회**하는 방식을 제안. (후자 선호)
- 이를 위해 `ERP Service` 같은 브릿지 계층을 통해 외부 속성을 가져올 수 있는 통로가 필요.

39:06~48:09
**`P-Executor` (Attribute Resolver) 개념**
- `P-Executor`는 **속성 해석기**로, 특정 항목(Prop ID)의 속성(`Validator` 등)을 요청받으면 캐스케이딩 규칙(내 설정 -> 양식 -> SC -> 공통)에 따라 최종 값을 찾아 반환하는 모듈.
- 이를 통해 `Normalized Definition`은 최소한의 정보만 갖고, 복잡한 속성 조회는 `P-Executor`에 위임하여 구조를 단순하게 유지.
- `P-Executor`는 속성 정보를 알려줄 뿐, 직접 실행하지는 않음.

48:09~56:03
**기존 유저 액션 및 VMC/DMC 호환성**
- 기존 유저 액션은 **수정 없이 그대로 사용**해야 함.
- 이를 위해 `DMC`, `VMC`의 인터페이스는 유지하되, `setPropState` 같은 메서드의 내부 구현은 Flexion의 `AST Node`를 직접 제어하도록 변경.
- 서버 개발자는 Flexion의 내부 구조를 몰라도 기존 `DMC`만으로 작업 가능.
- `셋업(Setup)` 데이터는 최초 렌더링 이후에는 직접 제어하지 않고, `페이지 뷰 모델`을 통해 UI를 변경하도록 유도.

56:05~1:00:15
**내부 로직 vs. 외부 로직 (유저 액션)**
- `Validator`, `Formatter` 등 공통적인 로직은 **플러그인 수준(Flexion 내부)**에서 처리하는 것이 재사용성 측면에서 유리하다는 의견.
- 팝업처럼 비즈니스 로직이 복잡하게 얽힌 경우는 유저 액션으로 외부에서 처리.
- 이 둘을 구분하는 기준을 명확히 해야 함.

1:00:15~1:15:11
**VMC/DMC 동기화 및 향후 계획**
- `VMC`의 상태 변경이 Flexion의 `AST Node`에 동기화되는 로직 개발 필요.
- 하지만 당장 컴포넌트 개발에는 `VMC`/`DMC` 연동이 필수는 아니므로, 우선순위를 낮춤.
- `VMC`는 속성 변경 시 비즈니스 로직을 트리거하는 기능은 없으며, 오직 상태 변경 통보 역할만 함.
- 최종적으로는 **`VMC`/`DMC`를 유지**하면서, 내부 구현만 Flexion에 맞게 점진적으로 수정하기로 결정.
- 내일 다시 진행 상황 공유 및 리뷰 예정.
