새로운 노트
2025.08.04 월 오후 2:31 ・ 96분 47초
송민형


참석자 1 00:00
일단은 데이터 키 데이터 키랑 로드 키 관련돼서 이제 두 개 매핑

참석자 1 00:22
그래서 지금 데이터 키랑 데이터 키랑 로드 키를 이제 만들어서 저희가 주입하는 이거는 만들고 이거는 만들어서 주입하고 그리고 그거를 이제 플렉션 그러니까 ERP와 플렉션 간에 이제 약간 연동하는 작업을 일단은 하려고 했는데 이게 아마 정상적으로 이제 일단은 다 되어 있지는 않은 상황이고요.
왜냐하면 이제 이제 얘기는 하긴 했는데 아마 여기서 연동이 안 된 것 같고 그래서 금요일 날 노드 키랑 데이터 키를 저희가 제너레이터 할 때 컬렉션 ast 제네레이터 할 때 두 개를 이제 만들어서 저희가 관리할 수 있게끔 ERP가 관리할 수 있게

참석자 2 01:06
ERP가 왜 관리하지 저걸

참석자 1 01:07
그럼 ERP가 관리 안 하면 누가 관리해요? 주체가 누가 돼도 상관은 없어요.
근데 만들어내는 거는 지금 현재는 ERP이기는 해요.
봐봐 봐 지금 제너레이터 그러니까 플렉션 제너레이터를 다 이쪽으로 다 뺐어요.
해서 뭐 그리드냐 뭐냐 이게 나중에 이제 통합될 수 있겠지만

참석자 2 01:33
잠깐만

참석자 2 01:42
이거 열어봐 어디 있는지 알겠지

참석자 1 01:45
지금 4번에 있어요. 지금 피처요 네 피처에 있다고 네

참석자 1 01:54
여기 있어야지 그 뷰 모델 만드는 쪽에서 바라볼 수가 있어가지고

참석자 2 02:03
피처로 만들면 그러면 우리 피처 버리면 어떻게 되는데 나중에 10.0 가

참석자 1 02:09
이거 안에 것만 들고 오면 돼요. 이거 안에 것만 피처 같은 건 이거 피처는 필요가 없어.

참석자 2 02:14
아니 이걸 누가 실행하는데

참석자 1 02:16
이거를 실제로 실행하는 건 제너레이터 애들이 지금 그리 그리드 안쪽이나 이제 폼 쪽이나 이제 여기 이제 제너레이트 할 때 여기 피처 가져와서 요 녀석들이 다 이렇게 크레이트 그 시점에 맞게 크레이트 할 수 있게끔 일단은 이렇게 만들어 놓기는 했어요.
다르게 좀 봐도 해야

참석자 2 02:44
결국은 aht를 밖에서 다 만들어 놓는다는 거죠.

참석자 1 02:48
셋업을 가지고 이제 ast를 만들어내야 되니까

참석자 3 02:54
그러면은 이제 플렉션을 자체적으로 이제 테스트할 때 얘가 필요할 수 있을 것 같은데

참석자 1 03:02
그래서 그래서 아까 그 4번에 있는 이유 중에 하나가 지금 지금은 이렇게 저희가 이렇게 하나씩 다 가지고 있단 말이죠.
이거를 없앨 거야 플렉션에서 들어올 수 있게끔 플렉션에 크리에이트 함수를 제공을 하고 얘는 그거를 받아 써야 되는 입장이라서

참석자 2 03:24
뭐 하고 습관적으로 고개 끄덕끄덕하는데 거슬려 아빠 아

참석자 1 03:35
이해하고 끄덕이는 거야.

참석자 2 03:39
대충 조금만 봤습니다. 구조

참석자 1 03:41
그래서 지금 얘가 다른 데 있어도 되는데 4번에 있는 이유 중에 하나가 외부와 외부 UI UI가 이제 연결을 할 수 있는 공간이 있어야 돼서 이게 그래서 3번은 못 가고 그래서 4번에 현재

참석자 2 03:59
아니 그러니까 결국 그 플로우를 누가 그럼 재어 그러니까 인풋이 셋업이야 일단 셋업이고 아웃풋이 ast야 그럼 그 플로우를 밖에서 제어한다는 얘기잖아 지금

참석자 1 04:15
밖에서 아니요 아니요 아니요 아니요 5.0에서 제가

참석자 2 04:17
그러니까 5.0이 바뀌잖아. 그렇죠 그렇죠 여기서 그게 맞냐는 건데

참석자 1 04:20
그럼 누가 제어를 해줘요

참석자 2 04:22
내부적으로 제어해야지 그 사이에 뭐가 끼어들어갈지

참석자 1 04:25
내부적 내부적이라고 하는

참석자 2 04:27
플렉션 안에서

참석자 1 04:28
그렇게는 못하죠 왜 못해요? 플렉션은 이 형 타입만 제공해 줄 뿐이지 제어를 할 수가 없죠.
걔는 왜냐하면 걔도 독립적인 세계고 독립적인 공간인데

참석자 2 04:42
아니 그러면 그 사이에 인풋과 컬렉션 그러니까 ast를 만드는 그 사이의 로직들은 아예 제어를 못한다는 거잖아.
그 사이가 다 밖에 빠져 있으면 5.0 따로 있고 6.0 따로 있고 7.0 따로 있고 왜 왜 그렇게 해야 되지 따로 있다라는 게 그러니까 밖에 있어야 되잖아 지금도 5.0에 있는 거잖아.
결국은 네 ast를 만들어서 ast를 만든 걸 쏙 넣어야 되잖아.
그쵸 그러니까

참석자 1 05:15
그러니까 저는 지금 이게 여기에 있긴 하지만 그리고 얘가 여기에 있긴 하지만 쟤는 저는 이만큼 이 전체 다가 5.0이 들어가든 6.0이 들어가든 7.0이 들어가든 이거 자체를 떼고 싶거든

참석자 2 05:30
그러니까 오케이 그러니까 이거를 넣으라는 게 아니라 리졸버 그래 뭐 넣어 빼 그러니까 이거는 플레이션에 들어오면 안 되는데 뷰 모델 지금 이게 어쨌든 ast를 만드는 로직이잖아.
ast 만드는 로직이 밖에 있는 것과 ast를 만드는 그 플로우를 제어하는 로직이 밖에 있는 건 다른 얘기잖아.
내가 만약에 이런 거 ast 만들면서 단계별로 로고를 찍고 싶어 그럼 어떻게 찍어 그 코드를 어디다 넣어야 돼 그러면 act를 만드는 과정에서 나오는 여러 가지 그 과정을 제어를 못하잖아.
일단

참석자 1 06:15
어떤 제약을 하고 싶어요

참석자 2 06:17
인풋에서 ast가 나오기까지의 그 과정 그게 다 통으로 밖에 나가 있는 거잖아 지금

참석자 1 06:25
그렇죠 플렉션에는 없죠.

참석자 2 06:28
그러니까 그것까지 들어와야 되는 거 아닌가 코드를 넣으라는 게 아니야 이 로직은 밖에 주입을 받아야지 당연히 근데 결국은 어떤 내가 그때 얘기한 단계별로 인풋 엔트리 데이터 들어왔어.
그다음에 뭐 뭐야 단 네 단계 다섯 단계 섹션 먹어 어쨌든 그거를 그럼 어디다 넣을 거야 다 밖으로 뺀다고 그거

참석자 1 07:02
네 플렉션이랑은 전혀 상관없잖아.

참석자 2 07:06
아니 그 로직은 상관없고 로직을 실행하는 주체가 결국은 안에 있어야 되는 거 아니야 왜요?
그거 어떻게 컨트롤 해 그러면 나중에 에러 로그를 찍으라고 그러고 컨트롤이 가능 불가능하잖아.
밖에서 그러니까 결국은 플렉션 ast가 이제 인풋이 되는 거잖아.

참석자 1 07:32
지금 플렉션 입장에서

참석자 2 07:34
어 그러니까 그

참석자 1 07:35
그래야지 완전히 독립적인 세계가 되는 거지 걔는

참석자 2 07:39
아니 동창인 게 아니라

참석자 1 07:41
그렇잖아요. 어디에도 엮여 있으면 안 되잖아요.

참석자 2 07:44
그러니까 이 코드를 넣으라는 게 아니라 이걸 주입 받아야지 당연히 일정한 어쨌든 컨버전 하는 거잖아 지금 네 인풋으로부터 at 컨버전 단계 거치고 그다음에 이걸 기반으로 다시 재조정 재배치하는 과정을 거쳐야 되는데 몇 단계 있었잖아 지금은 여기서 ast 컨버전 단계인데 이게 이거 통으로 밖에 나와도 되냐는 거야.
이거 지금 밖으로 다 나와 있잖아. 아니

참석자 1 08:15
아니 이거가 실제로 주가 되는 인풋이 되는 애가 아이 셋업이잖아요.
그러니까 플렉션은 그 아이 셋업을 알 필요가 없는데 그거를

참석자 2 08:23
아니 이 코드를 그러면은 딱 플렉션에 진입하는 그 포인트가 어딘데 진입 포인트

참석자 2 08:59
아니야 일단 넘어가 다 이거 소스를 내가 보고 일단 해보고 알았어 넣었어.

참석자 1 09:06
그래서 여기서 이제 제너레이팅을 이쪽에서 이제 해내고 그거를 그냥 플렉션에다 그대로 그냥 꽂아 넣는 거거든요.
여기서 그러니까 여기서 이제 ast 친구가 있어요.
여기서 이제 제너레이팅 하면서 실제로 노드 키랑 데이터 키를 여기서 둘 다 다 만들어놔요.
이 안쪽에서 지금 로드 매니저 친 건데 데이터 뱅킹 이걸 이걸 보여드려야 되겠고 알겠어 어디 갔냐

참석자 1 10:05
지금 저희가 여기다 이제 최종적으로 여기다 이제 넣어주는데 이니 컴픽은 저희가 아이 셋업 바뀐 걸 가지고 이제 이쪽에다 넣어주는데 넣어줄 때 이 플러그인이랑 실제로 이 노드 정보 총 3개를 넣어준단 말이죠.
데이터 노드 플로그인 이 3개를 넣어주거든요.

참석자 2 10:27
노드는 그걸 거고 그냥 커스트럭터 있는

참석자 1 10:31
그렇죠 그렇죠 그 플렉션에 있는 노드 정보 뭐 쓸 거냐

참석자 2 10:40
플로그인 목록

참석자 1 10:43
이제 만약에 코드형을 쓴다 아니면 디시말 형을 쓴다 포맷을 쓴다 그러면 이제 뭔가 어떤 플러그인들이 있을 건데

참석자 2 10:50
코트를 이런 식으로 하는

참석자 1 10:51
그렇게 안 나올 거예요.

참석자 2 10:55
그러니까 이게 왜 아직 핫오픈이 돼 있지

참석자 1 10:57
이거는 플로그인을 정확하게 뭐 쓰는지에 대해서 아직 정의된 게 없어서 그래서 이제 창구만 만들어 놓은 상태거든요.
그래서 일단은

참석자 2 11:08
잠깐만 데이터 노드 플러그인 데이터는 어디야

참석자 1 11:12
이니셜 요거 네 지금 프롭스의 이니셜 컴피그 저 이거 이게 뭐라고 그게 아까 만들어놨던 이 제너레이터 모델이 정 ast ast

참석자 2 11:25
그럼 데이터는

참석자 1 11:26
이건 ast

참석자 2 11:27
그러니까 ast 노드 그러니까 ast 그냥 진짜 노드

참석자 1 11:32
진짜 노드

참석자 2 11:33
컴포넌트 컴포넌트랑 노드 이 용어를 뭐라고 해야 되지 어쨌든 그건 코드 노드 이런 거 드 그다음에 플러그인 컴포넌트 목록 데이터가

참석자 1 11:48
데이터 데이터 이거

참석자 2 11:49
아니 이건 노드라며 ast라며 거기에 이미 포함돼 있어 데이터가 이제

참석자 1 11:55
오케이 오케이 이게 이제 ast거든요. 그래서 이거랑 실제로 이제 ERP에 있는 데이터를 엮는 게 지금 여기서 이 친구가 이제 실제로 이 제네레이팅 하면서 여기다가 다 엮어주거든요.

참석자 2 12:09
그러니까 뷰 모델은 이미 반영돼 있다는 얘기죠. 그쵸 그러니까 노드에 act 상에 데이터가 이미 매핑돼 있는 상황이다.

참석자 1 12:16
그래서 여기 이제 노드로 키를 찾을 수 있거나 있거나 데이터로 노드를 찾을 수 있게끔 그 제너레이팅 단계에서 어차피 이 함수를 다 써야 돼서 이 단계에서 다 이렇게 매핑을 시킬 수가 있거든요.
데이터 데이터 매핑이든 노드 매핑이든 노드 정보도 결국에는 이게 헤더 정보를 만든다 그리드 정보를 만든다 홈을 만든다 아이템을 만든다 하면은 결국에는 이 제너레이터를 통해서 만들어지기 때문에 노드에다가 이렇게 노드로 이렇게 계속 수집을 할 수 있거든요.
일일이 하나씩 중복되면 이제 안 들어가고 그런 상황이라서

참석자 1 13:03
그리고 현재는 맨 마지막 그 데이터랑 연결되는 데는 아이템밖에 현재는 없어서 근데 그런 어떤 속성 이 아이템이 아니라 그런 폼이나 티 바디나 아니면 티 로우나 셀이나 그런 거에 따라서 뭔가 이제 데이터가 아니라 이제 더 매핑돼야 되는 정보도 있는데 그거는 뭐 데이터 매핑해 넣을지 아니면 어디다 넣을지

참석자 2 13:32
근데 일단 왜 이게

참석자 2 13:50
이게 ast잖아 이거를 ast 구조가 바뀌어 오면 어떻게 되는 건데 우리 뭐 하나 추가해야 되면 어떻게 해야 돼?

참석자 1 14:06
at 구조가 추가되면요.

참석자 2 14:08
우리 노드 형이 인벤트로 바꿨어 아니면 뭘 추가해야 돼 그럼 이걸 어떻게 해야 되지?
여기만 추가하면 돼요. 여기만 다 뒤져서 5.0 5.6 다 뒤져서 다 수정하고

참석자 1 14:21
그래서 그래서 제가 이제 말씀드린 게 아까 요 제네레이터 이걸 다 갖고 나가고 싶다라고 하는 게 지금 5.0에 들어와 있잖아요.
얘가 5.0에도 있고 싶지 않은 거야. 플랙션에도 있고 싶지 않고 5.0에도 있고 싶지 않은 거야.
5.0에 저 제너레이터라는 데는 그냥 꽂아주고 싶은 거야.

참석자 2 14:43
아니 이거를 플렉션이 안 있으면 이 형이 노드 플렉션이 안 가져 있으면 누가 갖고 있다는 거지.
그러니까 결국은 플렉션의 정의는 LST 노드의 형과 실제 각 프레임워크에서 다루는 데이터는 다르겠지.
그러면은 당연히 나는 이게 플렉션 안에서 이 최종 노드의 형을 만들고 실제로는 내가 가령 이런 거지 뭐 여기에 타입이 얘는 어쨌든 잠깐만 이거는 그러니까 여기는 이제 이게 폼 아이템이라고 확정됐으니까 이렇게 한 것 같고 그러니까 이게 어디 갔어 그린 셀이야 그럼 테이블 셀이잖아 그치 그러면 이거는 사실 5.0 프레임웍의 데이터에 따라 어떤 게 그럼 그리드 셀인지 어떤 게 그리 폼 셀인지 이런 거는 다르니까 다 다르니까 그 정도를 뭔가 제너레이팅 해 준 함수 정도만 빠져나가 있고 노드를 만들고 이 형을 결정 그러니까 그 데이터 실제 ast를 구성하는 로직이 당연히 안에 있어야 되는 거 아닌가 이것까지 다 빠져나갈 이유가 없어.

참석자 1 16:02
아니 그렇게 되면은 플렉션에 그것까지 있으려면은 5.6이든 6.0이든 그런 거에 따른 데이터 타입을 다 받아들여야 되잖아

참석자 2 16:09
은 줄 수 있지. 그러니까 최종 이 노드 정보를 여기서 다 생성하잖아.
밖에서 이것도 지금 노드 정보잖아. 이거 ast 노드 아니야 이거

참석자 1 16:19
맞아요. 플렉션이 있어요.

참석자 2 16:21
근데 이게 왜 밖에서 만들어지는 거야?

참석자 1 16:23
이거는 안에서 만들어질 거예요. 지금은 이렇게 밖에 있는데 이 생성하는 요거는 플렉션에서 이렇게 뭔가 제공을 해 줄 거예요.
그냥 크리에이트 크리에이트 리드 세 하면은 본인이 아니고 이제 이거는 플렉션 거

참석자 1 16:48
그러면

참석자 2 16:52
얘가 인쇄 로직 이런 거면 어떻게 할 건데 데이터 모델 그때 얘기한 거 막 쪼개야 돼.
1개 ast ast를 막 재생산해야 돼. 테이블이 처음에는 하나가 왔어.
근데 이게 실제로 렌더링 가려면 4개의 테이블을 만들어야 돼.
데이터 그쪽으로 그러니까 그런 로직들을 어디다 넣느냐

참석자 1 17:14
그런 로직은 결국에는

참석자 1 17:21
여기에 있어야 되는 거 아니에요

참석자 2 17:23
거기라는 게 5.0 프레임워크에 있어야 된다는 거잖아.
그렇죠 그러니까

참석자 1 17:27
그게 맞아. 그러니까 아니 그 데이터 주체가 5.0인데 그러면 그게 어디 있어야 돼요?
인풋이 5.0이잖아.

참석자 2 17:39
아니 그러니까 인풋 데이터를 주입을 받는 구조로 만들어 놔야지.
그러니까 가령 이거야. 내가 데이터를 한 벌 받았어.
근데 페이지 개수를 내가 설정할 수 있다 쳐 그게 그리드 개수라 쳐.
그러면 그거는 외부에서 5.0 데이터란 말이야.
페이지가 나는 3개씩 보일래 그리드 3개씩이라는 어떤 속성 정보겠지 속성 정보를 받고 그럼 그 속성 정보가 결국은 ast 노드를 결정하는 정보란 말이야.
ast의 노드의 개수를 만들어야 될 거 아니야? 3개로 그 3이라는 그 속성이 그리고 그 ast 노드를 구성하는 로직은 당연히 밖에 있겠지.
로직은 그러니까 어트리뷰트 내가 페이지 개수라는 어트리뷰트와 페이지를 구성하는 그 점표 데이터는 밖에 있는 거고 당연히 그거는 밖에 데이터니까.

참석자 2 18:38
근데 내가 이게 s 노드상으로 들어오는 순간 얘는 더 이상 페이지 no라는 그 어트리트가 아니라 우리 at 노드를 결정하는 어떤 중립적인 컴피그 정보로 바뀌고 이 데이터도 전표 데이터도 일반적인 어떤 우리가 노드를 구성하는 지금 매핑하고 있잖아 데이터 모델을 매핑하고 있잖아.
STL 그럼 중립적인 레이어로 한 단계를 바꿔놓고 바꿔 놓고 한번 그다음에 LG 노드를 쪼개는 거가 안에 있어야 되는 거 아니야

참석자 4 19:19
그거를 하나 패션 안에 전처리를 하나 두자는 말씀

참석자 2 19:22
다 다 그러니까 저 매핑하는 거야 밖에 있겠지 이게 얘네들은 밖에 있겠지.
근데 이거를 콜하는 로직들이 다 밖으로 빠져버리면 제어가 불가능한데 만약에 이걸 그럼 6.0을 간다고 했을 때 그러면은 소개 합계부터 해서 모든 로직들 그럼 또 만들어야 될걸 한 세트 그럼 또 나와야 될걸.
근데 소개 합계라는 어떤 일종의 컴피그 정보를 중립적인 데이터 형태의 그 모양으로 바꿔주고 다 5.0으로 가든 소개학계라는 게 6.0으로 가면 다른 데 있을 수도 있지.

참석자 2 20:23
이걸 일반화시켜야 나중에 개발 안 하지. 이거 내가 지금이야.
그냥 그리드 루프 돌면서 그냥 at 만드니까 심플하지 당장 현황 그거 이거 여기에 막 붙여서 했어.
5.0 5.6에 붙이면 또 해야 될 걸 이거 똑같은 거 안 할 수 있어 안 할 수 있나 데이터가 다를 텐데

참석자 1 20:53
그럼 이거를 그 프레임워크 그러니까 데이터 변경에 따라서 계속 만들어내는 거는 아닌 거예요.

참석자 2 21:02
데이터 변경에 따라

참석자 1 21:04
데이터가 이제 5.0은 이제 아이 셋업이니까 지금 아이 셋업으로 돌고 있단 말이죠.
근데 5.6이 되면 이제 아이 셋이 아니라 아 56이라는 i 56세 이렇게 만들어졌어요.
걔가 그럼 그거에 맞춰서 또 만들어지는 그런 작업 대상이 아니라고 생각하시는 거예요.
데이터 변경에 의해서 데이터 그 모습 변경에 의해서 얘는 변경이 돼야 되는 대상이 아닌 거예요.

참석자 2 21:32
변경 대상일 수는 있지. 그러니까 이 로직이 필요 없다는 게 아니라 이 로직을 주입받아서 결국은 단계 단계 데이터 LT를 구성하는 로직들이 컬렉션 안에서 이 플로우를 제어할 수 있어야 된다 이렇게 얘기해.
내가 지금 타입이 그리드야 그리드야 그지 1차원 데이터만 넣어줘.
그러니까 1차원 그러니까 1차원이라는 게 칸반이라 치자 칸반이야.
CRM 데이터 n개의 데이터 모델이 내려온다고 디핀션도 다 내려와 그럼 이거를 이 1차원적인 인풋 그러니까 프레임워크 데이터를 그대로 노드 ac 노드로 바꿔놓고 기계적인 거지 이거는 기계적인 거고 근데 이거를 그대로 못 그린다고 이걸 못 그리고 어떠한 룰에 의해서 이걸 다시 재가공해야 돼.
근데 그 제거 가공하는 것부터는 ast 기반의 데이터로 가공하게 해놔야 나중에 안 할 거 아니야 다시.
근데 지금 이대로 가면 어떻게 되냐면 셋업 받았어 CRM 받았어 열나게 막 5.0에서 데이터 만들고 NCT를 재가공해서 딱 결정된 것만 던져주잖아.

참석자 2 22:51
이렇게 그럼 나중에 우리 10.0 가 그럼 이게 똑같을까 데이터가 다르겠지 CRM 데이터가 다를 수 있겠지 그러면 또 셋업 만들어서 또 이걸 또 개발해야 된다는 거야.
그럼 두 번

참석자 1 23:02
가공을 해야 된다라는 말인 거예요. 지금

참석자 2 23:04
지금 해야지 그러니까 그러니까 그러니까 나는 그러니까 1 뎁스에 그러니까 최초 원천 데이터 정도만 바꿔놓고 그 이후에 가공하는 것들은 ast 구조대로 가야 이게 안 바뀌겠지.
나중에

참석자 4 23:25
예를 들면 이런 거죠. 유즈 페이지네이션이라는 기능이 있는데 원래는 ERP에서 페이지도 다 쪼개가지고 주고 너희는 받는 대로 그리게 하려고 했는데 플렉션을 여기서 그냥 어트리뷰트를 페이지네이션 하나만 주고 얘가 그거 보고 하면은 어떤 데이터 타입이든 그냥 똑같이 하지 않겠냐

참석자 2 23:42
왜냐하면 그 구성하는 로직들이 그럼 프레임워크로 나가버리잖아 다 제각각 지금이 그렇잖아 지금이 이게 봐봐 5.6 가려니까 집계 합계면 다 해야 돼.
또 근데 그 로직을 로직이 바뀐 게 아니야 그 데이터 구조 인풋 데이터만 바뀌었는데 똑같은 로직을 또 해야 돼.
그냥 매번 그러고 있다고 지금

참석자 2 24:09
그래서 그걸 레이어를 나눈 거야. 그때 그게 세 번째가 뭐였냐 레이아웃 그러니까 ast 컨버전 하고 그냥 이거는 진짜 1차원적인 데이터 컨버전이고 레이아웃 구성을 따로 ast를 기반으로 가야 안 하지.
나중에

참석자 2 24:38
귀 있어 봐봐. 기

참석자 2 24:48
어디 있어요? 컬렉션 컨트렉션

참석자 2 25:06
왜 안 했니?

참석자 2 25:17
어 푸시를 안 오네.

참석자 2 25:26
봐야 돼

참석자 1 25:27
아니요. 아니요 안 받아요 안 받아

참석자 2 25:33
아이 아

참석자 1 25:34
아무튼 그러면 이제 아무튼 플렉션으로 이제 변환을 해야 된다.

참석자 2 25:42
아니 일단 넘어가는 데 소스 좀 보고 내가 왜냐하면 이게 지금 추상적으로 얘기하면 이해 힌트가 나갈 수 있으니까 일단 오케이 알았어 이해했으니까 일단 나도 이거 못 봤으니까 소스를 그래서 해봐 봐.

참석자 1 25:58
그래서 지금 현재는

참석자 1 26:14
지금 데이터 데이터 이제 매핑 정보를 일단 만들어 줬고요.
그리고 이제 이 크레이트 되면서 원래는 여기서 이제 원래는 저희가 여기다가 테이블 쓸 거야.
그럼 테이블 로드 테이블 셀 테이블 로 이렇게 다 해줬거든요.
예전에는 근데 그거를 이걸로 수집할 수 있게끔 해서 최종적으로 여기에다가 이제 전달할 수 있게끔

참석자 2 26:42
이거는 잠깐만 이게 뭐야 컴포넌트 이게 컴포넌트야 네네

참석자 1 26:49
이게 테이블이든 그리드든 그러니까 그리드든 폼이든 이렇게 하나씩 지금 현재는 들어올 수 있게끔 되어 있는 상황이

참석자 2 27:00
이게 그러면 어디에 붙어 있는데요

참석자 1 27:03
얘는

참석자 2 27:04
팀 아까 뷰

참석자 1 27:05
dmcpu 여기에서 만들 수도 있을 거예요. 여기서

참석자 2 27:09
이게 그럼 엔트리다.

참석자 1 27:11
네 여기에 지금 요 녀석이

참석자 2 27:18
이게 그러면

참석자 1 27:19
네 걔가 ast

참석자 2 27:24
그러니까 이게 결국은 6.0 가 그러면 이거부터 시작이라는 거잖아.

참석자 1 27:31
그렇죠 여기가 시발점이죠.

참석자 1 27:40
노드도 그래서

참석자 2 27:41
저밖에 없다.

참석자 1 27:42
이게 수집만 돼요. 수집도 이제 아까 그 제너레이터에서 다 수집해 주고

참석자 2 27:49
플로그인 플로그인이나

참석자 1 27:52
그 플로그인은 아직 안 해놓긴 했어요. 그냥 아까 그냥 하드 코딩 하드 코딩 일단 해놓고 그것도 이제 노드처럼 이렇게 플로그인으로 이제 들어올 수 있는 상황이지 않을까 싶어가지고

참석자 2 28:08
이거 이거는 왜 여기 있지? 이거는 뭔데 레이아웃이 뭐야?

참석자 1 28:15
그냥 하나 만들어 놓은 거 예전에 가지고 있던 5.0이 사용하고 있던

참석자 2 28:24
이거는 5.0에 있는 거야. 플렉션이

참석자 1 28:27
5.0에 있는 거예요. 걔는 이거 이거

참석자 2 28:30
이게 왜 5.0이었지 그럼 얘가 왜 5.0이었어?

참석자 1 28:36
일단 이것도 이거 샘플로 만들어놨어.

참석자 5 28:50
이게

참석자 2 29:02
이게 승현이가 만든 거 그러니까 이게 ERP 그러니까 플렉션 ERP로 이거 이게 빠져야 될 것 같은데 통으로

참석자 2 29:20
프로바이더가 그러니까 결국 여기서 플렉션 그럼 플렉션을 누가 창조하는 거야?
컴포저 그러니까 이렇게 하면 안 되고

참석자 1 29:30
저것도 없앨 거예요.

참석자 2 29:31
이거 ERP가 다 가져가야지

참석자 1 29:33
ERP 지금 ERP잖아.

참석자 2 29:35
아니 승현이가 하는 거

참석자 1 29:37
그쪽이 그쪽

참석자 2 29:38
플렉션 레이어를 뒀으니까 거기서 의존성은 다 가져가야 돼.
이거 직접 참조하면 안 돼요. 그러니까 진짜 노드를 만들어서 플러그인은 노드를 만들기 위해서 참조하는 건 오케이 오케이 그러니까 이거는 정리 일단 그럼 빠지면 될 것 같고

참석자 1 29:56
일단 플러그인도 참조를 안 할 거고 로드도 참조를 안 할 거고

참석자 2 30:00
왜 그럼 어떻게 개발해? 형은 참조해야 돼

참석자 1 30:02
형은 되게 소수만 참조할 생각이거든요. 그래서 이게 이렇게 주입한 것도 이 노드 수집은 아까 어디 있어?
제너레이터 하면서 수집은 하겠지만 수집한 거야

참석자 2 30:22
그거를 동적으로 구성한다고

참석자 1 30:25
그냥 그쪽에서 파인드 함수만 하나 이렇게 주거나 리졸브 함수만 주거나 이러면은 노트를 찾아올 수 있거든요.

참석자 1 30:36
지금은 얘가 에드 하면은 얘는 딱 박아놓긴 했거든요.
이것도 지금 이렇게 박아놨거든요. 이것도 없애고 라고 하는 거

참석자 2 30:52
이게 뭐 필요한 거

참석자 1 30:54
그러니까 이거 필요 없어요. 이거 없앨 거라서

참석자 2 30:58
여기서 그럼 애들은 왜 하는 노드 키 때문에

참석자 1 31:01
노드 아까 주입을 해줘야 돼서 최초에 이 노드를 주입을 해줘야 돼서 안 그러면 얘가 뺑뺑이 한 번 더 돌아서 이걸 다 찾아내야 돼요.
콜렉션에서

참석자 2 31:26
그거를 굳이 런 타임에 할 이유가 있나 그러니까 저거는 내가 쓰는 것만 등록한다는 의미잖아.
그 역량이 있나 다 등록해 놓은 거 노드에 어차피 확장돼 있을 텐데

참석자 1 31:45
그러면은 뭐 이렇게 할 필요는 없어요. 저렇게 수집하고 한 번에 다 주입할 거면은 할 필요는 없고 이거는 딱 그냥 쓰는 데만 주입하려고선 되어 있는 거라서

참석자 4 31:59
근데 쓰는 애만 주입해놔야 그 쓰는 노드들에 대한 플러그인만 등록하기에 좋을 것 같기는 해요.

참석자 4 32:09
이게 결국 노드 매니저 에드 하는 쪽에 결국 플러그인 쪽이랑도 연동이 될 것 같은데

참석자 1 32:17
그러니까 연동은 안 되고 따로 떨어뜨려져 있기는 한데 근데 하는 행위는 비슷하긴 하죠.

참석자 4 32:24
그래서 등록된 건나 플러그인을 다 꽂으면 너무 리지스트가 많이 되니까 개념상

참석자 2 32:50
뭔가 결국은 그러면 이걸 해야 된다는 얘기잖아.

참석자 1 32:56
결국 사용하는 애만 쓸 거면은 이 행위를 해야 되는 거고 말씀하신 대로 그게 필요 없다라고 하면은 굳이 요구 안 해도 돼요.

참석자 1 33:13
다시 제가 셀 같은 경우는 막 3개 4개 10개 100개 이렇게 들어오니까 그 테이블 셀 같은 경우는 하나만 넣으려고

참석자 2 33:20
그러니까 캐시 캐시

참석자 1 33:22
네 사실 단순히 그 용도로

참석자 2 33:44
이거는 일단 이거는 좀 전반적으로 플로우를 좀 다시 봐야 될 것 같아 잠깐만 그러면 지금 오늘의 더 있나 해봐 다 된 거고

참석자 1 34:02
네 네 그 다 이제 금요일까지 해서 그렇게 해서 현재 출력되고 있는 게 이제 위에 이제 폼이랑 이제 그리드

참석자 2 34:13
그러면 이거 하나를 추가하기 위해서 뭘 해야 되는데 한번 설명해 볼까 하나를 추가하기 위해서 이거를 뭐 하나 내가 누가 저걸 시켰어 하나 넣어야 돼 그럼 뭘 해야 돼 뭘 넣어야 되는 거 어떻게 개발해야 되는 폼 폼 아니면 폼 그냥 뭐

참석자 1 34:30
포맷 포맷 지금 지금은 거기까지는 안 그리긴 했는데 마도 만약에 레이아웃이 된다라고 하면은 이런 일을 하나 만들어야 될 거 아니야 플렉션 있다 치고 있다 치면 홈에 넣는다 치면은 이제 플렉션 리액트 아마 위에 하나씩 들어갈 거라서 항목들이 들어갈 거라서 이것만 이 노드랑 실제로 이 노드랑 컴퍼넌트 정도 만들 것 같아요.
컴포넌트 두개 만들고 그리고 아까 그 ast 플래시 ast 제너레이터 여기에서 만약에 이거는 안 해도 될 것 같고 지금 지금 데이터 타입별로 나눠놨거든요.
지금 코드형인지 데이터형인지 만약에 다른 형이 있다라고 하면은 이제 그거에 대해서 아이템 b 모델을 하나 생성해 줘야 ast 명칭을 좀 바꿔놓고

참석자 2 36:00
이거를 누가 호출하는데 그 제너레이터 거기서 호출한다고 네 여기

참석자 1 36:05
네 그 안쪽에서 계속 돌면서 해주고 하고는 있어요.
제일. 그래서 저희가 메뉴 프로 해서 이제 아까 파인드 데이터 타입 리저브 치면 여기 찾아와서 그거 해서 이제 발표 모델 만들고 ast 만들어내면 맞는 걸 이제 하리한테 계속 꽂아줘.

참석자 2 37:13
그럼 뭘 해야 되지

참석자 1 37:15
지금 남아 있는 거는 말씀하셨던 프로바이더 쪽

참석자 1 37:25
지금 여기가 어떻게 설계할지 어떻게 작업을 할지를 좀 보기는 해야 될 것 같아요.
지금 나머지는 아마 아까 저 플로우대로 타고 들어가면은 그냥 그려지고 동작되고 할 거거든요.
근데 가장 지금 제가 봤을 때 시급한 건 얘인 것 같아요.
이렇게 이렇게 여기에 대야 값을 변경하고 이제 이런 거를 좀 테스트를 해볼 수 있을 것 같아요.

참석자 6 38:24
근데 뭐가

참석자 6 39:41
그거 다 쓰는 거 같아 좋다. 여기 쓰는 거 같아

참석자 1 39:48
예 쓰고 있어요.

참석자 2 40:36
이거 좀 이거 이렇게 볼게 안 되나

참석자 2 40:49
이것도 쓰는 건가

참석자 2 41:49
일단 페이지 뭐야 현황에 그 건수 3개씩 보일지 그 몇 개씩 보이지 그것만 한번 해서 어떻게 하는지까지 좀 고려해서 얘기해야 될 것 같은데 여기저기 넣어봐야 될 것 같은데

참석자 1 42:08
네 그래서 아마 그거 이제 그거랑 약간 비슷한 게 저희가 원래 가상 스크롤 하려고 했잖아요.
제 랜더링 그런 맥락으로 아마 플렉션 재생성해는 이거를 좀 아마 정현 책임님이 확인

참석자 2 42:27
근데 이게 이렇게 해서는 저게 가능해 재생성 어떻게 하지 재생성을 어떻게 하지 이게 이미 어트리뷰트 그러니까 이게 지금 at를 재생산하는 게 아니고 그치 이게 ST니까 그걸 어떻게 재활용할지를 보면 그러니까 5.0에 두면 안 되잖아

참석자 2 43:00
5.0이 둬야 돼

참석자 2 43:09
가상 스크롤이나 쳤을 때 그러면은 뭘 한다는 거지 이게

참석자 1 43:23
맨 뒤에 있습니다.

참석자 2 43:25
그 얘기 뭐 있는데 무슨 내용인데 뭘 한다는 거지

참석자 4 43:31
아예 그거 생각하셔서 써놓으신 것 같은데 가상 스크롤 할 때 그러니까 ac 노드는 그러니까 원래 제가 테스트했던 건 t 노드는 다 만들고 HTML만 부분적으로 만들었는데 아예 ST 노드 자체도 부분적으로 만드는 부분을 놓치는 거

참석자 2 43:50
아니 아니야 그런 거 아니야 그러니까 버추얼 스크롤은 나는 뭐 얘기한 게 없는데 그거 관련해서는 그러니까 나는 인쇄나 이런 거 현황이나 ST 노드 자체를 다시 만드는 거를 얘기하는 건지 이게 재생성이라는 게 내가 이게 무슨 말인지 몰라서 이게 가상 스크롤이랑 상관있는 얘기네.
이거 아니 가상 스크롤을 얘기하길래 내가

참석자 1 44:15
네네네 원래는 그 말씀하신 것처럼 진영 측이 아시고 하신 것처럼 지금 100개면 100개를 다 만들고 도매 조금씩만 붙인다 였는데 저는 100개인데 20개만 그리고 20개만 만들고 그때그때 다시 만들어낸다.

참석자 2 44:32
그러니까 그 얘기를 하는 거야. 그게 그 얘기를 하는 재생성이라는 의미가 그 얘기를 하는 거야.

참석자 1 44:36
100개면은 20개만 만들고 일단 다 뿌려준 다음에

참석자 2 44:39
이식 게임을 어떻게 만들어 아니 그러니까 최초

참석자 1 44:42
네 최초

참석자 2 44:45
잠깐만 알았어요. 그거는

참석자 1 44:48
그것 때문에 이제 재성생이라고 말을 쓰긴 했어요.

참석자 2 44:51
그러니까 버치 스크롤 그거는 다 가능하게 해야 될 것 같은데 선택할 수 있는 구조

참석자 4 45:00
그러니까 ast도 보는 만큼만 만든다 이거는

참석자 2 45:03
그러니까 그것도 여차하면 뭐 할 수 있는 수준으로는 해놓으면 되니까

참석자 4 45:10
이게 메모리 때문이죠. 그렇죠

참석자 2 45:17
근데 뭐 메모리가 많이 없나 은 돔을 안 만들고 노드는 들고 있어야 되는 거 아니야 일단 잠깐만 이걸 해야 된다.
그러니까 할 거 할 거 얘기하면서 이거는 승현이 와서 정리해야 되고 그다음에 남은 건 이걸로 하면 된다.
맞아 네 그걸 그러면은 그건 뭔데 그럼 붙일 수 있다는 얘기인가

참석자 1 45:45
아그렇죠. 저 승현이 것만 되면은 일단은 뭐 될 것 같기는 해요.
그래서 일단은 지금 폼이랑 버튼 정도 일단 지금 해보고 있는 상태이긴 하거든요.
아까 말씀드린 대로 로드 만들고 이쪽에서 ASP 만들어주고 이 정도만 작업하면 들어갈 수 있지 않을까 싶어서 일단 작업은

참석자 4 46:15
아까 부분 네이스티 만드는 것도 지금 진행해야 되는

참석자 2 46:20
그럼 이거 이거를 그럼 어떻게 해 이거를 가능해 이게 그 부분으로 만드는 거면 여기서 부분으로 만든다는 얘기 지금 그 얘기가 그러지 이거 어떻게 가는데 그러니까 그래서 내가 그런 얘기야 이 플로우를 전체적인 이 제네릭한 플로우 제어하는 로직이 다 밖에 있어 버리면 우리가 할 수 있는 게 없어 그냥 모든 걸 다 다 나가야 돼.
거의 지금 당장 이것만 해도 안 되잖아. 그럼 또 여기다 해야 되잖아.
이거는 어떻게 못하지 사실

참석자 2 47:09
그러니까 ast를 만드는 플로우 설계를 내부적으로 하고 그 플로우에 들어올 제너레이터를 주입받고 결국은 여기 안에서 이거를 뭐든 제어를 해야 우리가 마음대로 할 수 있지 나중에 근데 지금은 그 제어권이 바뀌었다 그러면은 이거야 되겠지 심플하게 근데 CRM 딱 들어가 버리면 안 될걸 그러니까 안 된다 이거 되지.
근데 코드 관리가 안 돼. 똑같아 그러니까 지금이랑 똑같아.
5.0과 5.6이 거의 90% 똑같은 코드가 지금 늘고 있어.
2배로 왜냐 어쩔 수 없어. 그냥 둘 다 하려면 그냥 똑같은 페어로 계속 와야 돼.
근데 지금도 이 상태면 그럴 수밖에 없어. 당장

참석자 2 48:14
일단 이거는 뭐 그냥 병행 이거는 어차피 계속 설계해야 되고 병행하면 되고 그러면 이 지금 중요한 건 물론 내부적인 코어 쪽 정리하는 건 계속할 텐데 그리드 기능 빼놓은 거 그거 어떻게 개발할지 아까 문서 있었죠 투드 그리드 쪽 플러그인이든 뭐든 그러니까 뿌릴 거 개발자들 뿌릴 대사 이거 폼도 해야 되는데 폼은 많이 없으니까 그다음 아까 그 컴포넌트들 이런 거 두 개를 뿌릴 거잖아.
그 다음 주에 그럼 이거를 개발 환경 테스트 환경 세팅 이거 이거를 집중해줘.
일단 코어 쪽은 일단 어차피 병행하면 되고 좀 다시 설계를 해야 될 것 같고 그러면은 이번 주에 집중할 거는 저것들 개발 방법론 가이드 개발 환경을 세팅해야 될 것 같은데 특히 테스트 개발이 가능해야 되잖아.
독립적으로 해야 돼. 저거 막 5.0 붙여서 하면 안 돼.

참석자 3 49:44
5.0에서 이제 라이브러리 같은 거 스테틱으로 관리하고 있잖아요.
뭔데 로데이나 그런 거를

참석자 2 49:52
그런 거는 그러니까 환경 구성해

참석자 3 49:53
그런 거는 사용할 수 있게요.

참석자 2 49:55
아니 그런 거는 테스트 기본 페이지에 세팅은 해줘야지.
그 정도는 로데시나 기본적인 라이브러리들은 당연히 지금도 플레이 뭐야 스토리북이 있잖아.
네 스토리는 계세요.

참석자 2 50:18
근데 승현이 께 돼야 되잖아. 이거 상태 바꾸고 뭐 이런 건 해봐야 되지.

참석자 2 50:28
결국 얘네들 별로 at 노드의 타입을 다 명세해야 돼.
타입 명세 당연히 그 타입에 포함되는 기능들 다 돌아가야 되고 그다음에 포매터 다 포함되는 거고 리졸브 각종 속성들 그러니까 5.0의 속성들이 다 들어와야 돼요.

참석자 2 51:05
이거는 그러면 그리드 그때 진경 씨가 해보라고 한 거 있잖아 몇 개 뭐였지 포커스 아니 그니까 훅이 아니라 플러그인 플러그인이 어떤 식으로 개발할지가 리사이즈랑 몇 개 있었잖아 되겠나

참석자 4 51:27
김용 구현은 아세요?

참석자 2 51:29
그러니까 구현이 아니라 뭐 대충 가이드 정도는 줄 수 있어야 되니까 준성 님이 하면 되는 뭔지는 알죠 그때 얘기한 거 두세 개 정도 지금 코드나 덱시을 한 것처럼 동작이 안 돼도 어느 정도 컨셉이라도 있어야 되니까 그리고 검증은 해봐야 되니까 되는지

참석자 2 52:04
무슨 말인지 이해하셨어요? 그렇죠 그거 그러니까 이런 거를 그냥 하나씩 다 어떤 식으로 개발할지를 진짜 설계를 좀 하긴 해야 되는데 주기 전에

참석자 4 52:22
제가 지금 딱 그리드가 기본 틀이랑 헤드 이런 거 분리랑 각자 프레이트 도 다시 다르게 하는 것까지 딱 기본 물병만 돼 있고 그래서 저는 오늘부터 이제 위에서부터 기능 구현을 하려고 했는데 플러그인이 필요할 기능으로 하려면 플라미나부터 하면 안 되고

참석자 2 52:49
그게 무슨 말이에요? 기능 이거

참석자 4 52:51
그래서 위에서부터 이제 이렇게 중요성이 이렇게 내려가는 것 같아서 컬러 문화 랜더링부터 이제 오늘부터 구현 시작하려고 했거든요.

참석자 2 52:59
그러니까 준성 님이 해. 그럼 준성 님은 뭐 하는데

참석자 4 53:04
선수 님 아직은 TP 중이셔서 네 아직은 못 붙으셨어요 그때 뭔가 플러그인을 만들어서 그 플로우를 가이드를 해주려면 저런 기능은 뷰 단 바꾸는 건 안 될 것 같고

참석자 2 53:19
이런 거 이게 제일 적당한 거

참석자 4 53:21
리사이즈나 포커스나 이런 쪽

참석자 2 53:22
포커스 이거 행 추가 이런 거 다 다 이런 거 다 해봤은데 이런 거 다 해볼 것 같은데 형 너 뭐 하니?
저 지금 전화 오늘까지는 더 해야 돼 바로 스테이지 해가지고 스테이지 추가

참석자 4 53:38
그러면 네 플러그인 붙어서 볼 수 있는 간단한 플로우를 하나

참석자 2 53:42
그러니까 컬럼 분할은 저걸 오히려 늘려도 될 것 같아요.

참석자 2 53:50
그럼 정리 좀 해봐.

참석자 2 54:00
그리드 플러그인 플로그인 배가 아

참석자 2 54:13
그건 뭔데 그리드 개발한 거야 아까

참석자 1 54:16
그리드 개발하려면은 기능 나눠서 하려면

참석자 2 54:20
잠깐만 그럼 민영이 너는 뭐 하는 거

참석자 3 54:23
그럼 저 개발 환경 플레이 그라운드예요.

참석자 2 54:29
플레이 그라운드 그건 뭐야?

참석자 3 54:33
거기서 이제 컴포넌트나 플러그인 같은 거 넣었을 때 작동하는 거 확인할 수 있도록 하는 거

참석자 2 54:40
개발 환경이야.

참석자 2 54:48
그러면 민영이가 개발 환경 테스트까지

참석자 4 54:55
저 저 플러그인 개발 있잖아요. 그 플러그인 등록하고 하는 프로바이더를 만들었는데 나은진 사장님도 플러그인 관련된 거 만드신 것 같아

참석자 1 55:06
없어요.

참석자 4 55:07
매니저 피처는

참석자 1 55:08
근데 아무것도 없어.

참석자 4 55:11
그럼 제가 그걸 활용해서 넣어도

참석자 1 55:12
네네네. 플로그인에 아무것도 없어요. 지금 그냥 노드랑 똑같이 만들어야지.
약간

참석자 4 55:17
네 넣을 수 있는 작업이랑 그리드에 있는 거 하나 기능 연결해서 하는 거.
네

참석자 2 55:33
플로그인 그러니까 저거 프로바이더 형태로 그러니까 지금처럼 참조가 안 되는 거 알죠?
플러그인 내가 쓰는 플러그인이나 노드나 결국은 런 타임이 결정되는 거잖아.
네 맞아요. 그렇죠 어트로비트 받아서 만약에 유즈 체크 박스다 그런 어트리뷰트가 있으면 이런 플로그인이 로드 돼야 돼.
네 그렇죠 그러면 플러그인은 결국 그 말은 참조를 못한다는 거고 그렇죠 어떤 팩토리를 통해서 런 타임에 받아와야 되잖아.
그렇죠 그러니까 그것까지 고려가 돼야 될 것 같은데 그렇죠 정의를 어떻게 그러면 플로그인 어떻게 정의하 컴포넌트도 마찬가지인데 이거 지금 이렇게 해서 이게 가능한지 노드 이건 노드가 노드를 아까 수집한다고 어떻게 수집을 해 노드를 그러면 노드를 어떻게 렌더링 해 뭐를 수집하는 거지 안 해 봤 거기 아니야

참석자 1 56:46
아니야 최종적으로 여기 있을 거야

참석자 1 57:04
이게 있어야 돼요. 얘를 통해서만 찾아올 거예요.

참석자 1 57:12
왜냐면 어차피 여기가 아까 그 주입된 게 플래시 저 멕시컬 어디 가지

참석자 2 57:19
아니 왜 저거만 왜 또 멕시코에도 왜 나왔어

참석자 2 57:32
그러니까 렉시컬 노드라는 게 뭐지 뭘 의미하는 컨트랙터를 얘기하는 거야 형이 뭔데 렉시컬 노드 렉시컬 노드 렉시컬 로드 노드

참석자 1 57:46
너 미친놈들

참석자 1 57:51
알겠습니다. 예

참석자 2 57:54
이거는 그러니까 이게 경력 인데 이게 뭔데 전체

참석자 1 57:57
멕시컬 로더가 최상위의 객체

참석자 2 57:59
그러니까 컨트록터 얘기하는 거야. 최상위 노드 노드라는 게 뭔데 클래스 그러니까 컨트로터 얘기한 거 아

참석자 1 58:06
맞아요.

참석자 2 58:09
그러니까 이거는 인포트를 해야 된다는 얘기야. 인포트를 안 한다고 근데 쟤를 어떻게 넣어 여기서 찾아오면 되니까요.
아니 아니 피처에 등록을 해야 될 거 아니야 지금

참석자 1 58:22
피처 어디

참석자 2 58:23
아까 뭐 매니저니 뭐니

참석자 1 58:25
아니야 아니 애들만 친해.

참석자 2 58:28
그러니까 애드 할 때 뭘 에드 하냐고

참석자 1 58:29
단 지금은 지금 현 요 녀석

참석자 2 58:38
아니 그러니까 이게 뭔데 뭘 하는 건데 그러니까 이거를 결국은 인포트를 해야 된다는 얘기잖아.
포트 안 해도 되니까 안 한다고 근데 어떻게 컨트롤트를 그럼 여기 그러니까 내가 이해를 못하는 거 지금 그러니까 지금 얘로 찾는다는 거잖아.

참석자 1 58:53
개로 얘가 인풋이 되고 얘가 아웃 푸셋이 되는 거예요.
그거를 여기서 여기다가 인풋을 넣고 여기다 이제 아웃풋으로 하면은 하나씩 다 다

참석자 2 59:05
그러니까 결국 파인드 노드에서 저 인포트를 해서 리턴을 한다는 얘기잖아.
컨트롤 그러니까 결국 인포트를 한다는 얘기잖아.

참석자 1 59:16
얘는 있어야지 얘는 서비스 이게 ERP랑 연결고리라고 하셨을 때

참석자 2 59:33
그러면 이거는 그러니까 이거 내가 이거 얘기할 때 노드 그러면 외부에서 등록한 노드는 어떻게 찾아

참석자 1 59:42
외부에서 등록한 노드

참석자 2 59:45
이거가 지금 코어 쪽 그러니까 렉시컬 내부에 있다는 거잖아.

참석자 1 59:49
그럼 이게 먼저 등록이 될 거잖아요. 그럼 여기서 찾을 때 당연히 등록된 것까지 다 찾겠죠.
본인이 가지고 있는 거 플러스 내부에서 등록한 거 다 여기에서 찾을 수 있을 테니까 아니면

참석자 2 1:00:16
이거를 왜 그러니까 서비스로 이게 왜 필요하지 그러니까 파인드를 왜 이걸 밖에서 파인드로 할 일이 있다는 얘기야.

참석자 1 1:00:26
그러니까 타입을 최소한으로 노출하려고 했던 건데 그렇게 안 해도 돼 상관없어 이렇게 써도

참석자 2 1:00:32
아니 그러니까 완전 반대라서 그래 인식이 관점이 이 프로바이더를 만든 건 외부에서 등록만 그러니까 외부에서 등록하고 내부에서 찾아 쓰겠다는 거거든.
사실은 등록하는 걸 열어준 거고 이건 뭐야 찾는 걸 열어준 거야.
그러니까 내부에 내가 내부에서 다 등록해놓고 찾는 것만 열어준 거잖아.

참석자 1 1:00:57
제네레이터가 밖에 있어서 찾아야 되니까

참석자 2 1:01:01
잠깐만 그러면 LG 노드에 컨트롤터가 온다는 얘기야.
타입이 그냥 형이 아니고 그러니까 어디 어디 어디 지금 그 말은 렉시컬 노드라는 게 실제 이거 노드잖아.
그러니까 이걸 뭐라 엘리먼트 이거 뭐라고 그래 클래스라 표현할 게 아니라 클래스 컨트럭터 그지 ast 노드에 레퍼런스가 온다는 얘기야.
어디에 ast에 이게 지금 ast 제너레이트 할 때 이걸 쓴다며 그러니까 그거는 ast를 구성하는 건데 그러면 ast 상에 저 컨트럭터의 레퍼런스를 넣어야 된다는 얘기 아니 아니 아니 그러면 쟤가 왜 필요한 거죠 타이드는

참석자 1 1:02:03
저희가 이렇게 이렇게 넣잖아요. 실제 ast를 이렇게 만들잖아요.
이게 ast거든요. 그리고 지금 ast 현재 이 함수의 인풋인 거고 그러면 결국에는 저희가 그 에디터 플렉션을 만들어낼 때 노드 즈라는 애가 필요로 해요.
근데 여기에 필요한 게 결국에는 래시컬 로드거든요.
로드 목록들이거든요. 그러면 이 테이블이라는 애를 만들면 여기 하나의 테이블 노드라는 애가 필요해요.

참석자 2 1:02:37
그러니까 노드를 만들기 위해서 필요하다는 얘기잖아.
ast가 아니고

참석자 1 1:02:42
그렇죠 그렇죠 실제로 이제 플렉션 안에서 이제 구성을 하기 위해서 이제 필요한 정보인데 그 정보를 저 ast를 만들 때 여기 인풋으로 넘겨주면은 반환 값으로 이제 테이블 로드로 이제 반환해 주

참석자 2 1:02:57
그러니까 여기에 결국은 이거를 알면 이것만 알면 다 알 수 있는 거 아니야 다 알 수 있는 거야.
근데 이거는 이걸 왜 노출을 해 주지

참석자 1 1:03:07
이때 쓰려고 이때

참석자 2 1:03:09
아니 그러니까 이거를 그럼 밖에서 안 넣어도 된다는 얘기야.
지금 이게 지금 아까 프로바이더든 엔트리에 얘를 넣으려고 하니 밖에서 5.0에서 그럼 이걸 열어줬다는 얘기

참석자 1 1:03:24
그렇죠 그렇죠 그러니까

참석자 2 1:03:25
근데 이거를 굳이 안 해도 되는 거 아니야 왜 안 해도 되죠?
어차피 이거 보고 만드는 거 아니야

참석자 1 1:03:31
그거 보고 그거 보고 만드는데 미리 주입을 해줘야 됐었죠.
노드즈라는 애를 말씀하신 대로 할 수 있어요. 그러면 여기 가져와가지고 전체 뺑뺑이 한 번 다 돌면서 너 테이블 너 타입 뭐 있어 싹 수집해가지고 중복된 거 다 제거하고 하면은 수집이 가능해요.
내부적으로도

참석자 1 1:03:56
근데 그거 한 번 더 안 돌리려고 외부에서 돌리면서 같이 수집하는 거라서 단순히 그 이유밖에 없어요.

참석자 2 1:04:05
아니 그러니까 이게 잘 생각하라고 이 인터페이스를 설계할 때 그런 목적이 아니란 말이야.

참석자 1 1:04:15
그러니까 그래서 그래서

참석자 1 1:04:25
그래서 여기 하시는 분들이 잘 설계를 해줘야 그러니까 나는 이렇게 생각했는데 그런 게 아니다라고 하면은 그거에 대해서 뭔가 방안을 제시를 해줘야 할 수 있지 않나

참석자 2 1:04:44
그러니까 이거는 들어오면 안 될 것 이건 안 돼 이 목적이 아니야 이런 식으로 그러니까 뭔가 내부에서 쓸 로직을 위해서 API를 제공하는 컨셉은 그러니까 그 반대가 돼야 돼.
내가 이거를 열어주고 밖에서 계속 쓰게 하면 안 돼.
결국은 다 똑같은 맥락이야. 내가 의존성이 계속 커진다고 밖에 코드를 그러면 계속 그거를 제어를 해줘야 돼.
내가 쓸 걸 받아서 그냥 이거는 받는 거야. 주입 받는 모델인 거고 밖에서 이런 거를 네가 주입해 주고 주입하고 끝인 거야.
그 라이프 사이클 제어를 내부적으로 하라는 얘기야.
이것도

참석자 1 1:05:33
그럼 마지막으로 하나 마지막에 이제 하나 궁금한 게 있는데 이거랑 이제 비슷한 제네레이터 제네레이트 해 주는 애 얘는 제네레이트를 위해서만 이제 존재 하는 거거든요.
근데 이제 근데 말씀하신 것처럼 얘가 필요 없다 치면 제네레이트 하는 애도 이 안쪽으로 여기에서 뭔가 해야 되는 거예요.

참석자 2 1:05:58
그치 아니 거기가 아니라 결국 그거지 이 역할은 뭐냐 하면 결국은 내가 제너레이터 할 때 필요한 로직들을 주입해 주는 거고 그 로직을 제어하는 거는 안쪽에 있어야 이렇게 예를 다 이렇게 디피니션을 인풋을 넣었어.
그냥 그러니까 이렇게 되겠지. 여기에 이 서비스에는 어떤 아까 내가 얘기했던 그때 이렇게 네 단계의 레이어에 해당하는 프로바이더가 등록을 해야지 걔가 처음 셋업에서 이렇게 만든 거 그다음에 그 at를 기반으로 재가공하는 컴피거 만드는 어떤 로직 그런 걸 주입 받아놓고 내부적으로는 플렉션 컨텍스트 구성할 때 프로바이더 지 프로바이더에 넣었으니까 그럼 거기서부터 그냥 콜인 거야.
내가 그 콜백이 그런 거지. 콜백을 내가 받아서 실행만 하는 거야.
실행만 하라고 다 그 안에 로직은 넣으라는 얘기가 아니야.
그래서 그 실행하고 그 사이의 흐름들을 우리가 제어를 할 수 있어야 된다고

참석자 2 1:07:24
그러니까 그게 안 되면 이런 식으로 계속 내줄 수밖에 없어.
왜냐하면 밖에서 노드 에지 노드 만들면서 컨트로트는 있어야 되네.
너도 갖고 와야 되잖아. 그러면은 당연히 이런 식으로 API를 제공해서 그럼 니가 알아서 꺼내봐 꺼내봐 계속 그러겠지.

참석자 1 1:07:46
그러면 여기 뭔가 그 콜백을 5단계 중 다섯 단계를 넣는다 했잖아요.
그럼 그중에 첫 단계인지 두 번째인지 세 번째인지 간에 결국에는 외부 데이터가 어떤 모습을 가지고 있어라는 것도 주의를 해줘야 돼.

참석자 2 1:08:00
그거는 자기가 알지 리턴 타입 그러니까 그때 ST 컨버전이라는 레이어를 뒀어.
그럼 얘는 ast 컨버전의 인풋 데이터는 다 다르잖아.
아이 셋업이 올 거고 6.0은 템플릿이 올 거고 대신 아웃풋은 ast 노드겠지.
그러니까 그거를 자기가 구현을 해서 그러니까 그것만 구현하는 거지.
물론 그 안에 설비가 많아 그 레이어가 많아. 사실

참석자 1 1:08:30
그러면 이제 그거 이제 인풋은 외부에서 정했으니까 외부에서 쓰고 정해서 쓰고 제네릭으로 해서 쓰고 그럼 아웃풋은 정해졌어.
그러면 그 안에서 하는 행위들은 그 사람들이 그 사람이 알아서 다 하는 거네요.

참석자 2 1:08:45
당연히 해야지 자기가 해야지 그러니까 그 로직은 거기 있어도 돼.
제너레이터 그 로직을 다 넣으라는 건 아니지 아니 그러니까 그 설계를 안 했잖아 지금 그걸 나도

참석자 1 1:09:02
저는 약간 만드는 비용들을 다 줄이고 싶었거든요.
만드는 비용 아까처럼 노드를 찾는 비용 플로그인 찾는 비용 결국엔 다 떫을 수도 있어요.
깔끔하게 소스상으로는 그럼 그 이제 느려지겠죠.
그거는 왜 여기서 한 번 돌리고 두 번 세 번 네 번 다섯 번 돌렸으니까 한 번 돌려서 찾을 수 있는 비용으로 나는 다 쓰고 싶었던 거였는데 그게 아니라고 하면은 그렇게 설계를 할 수도 있어.

참석자 2 1:09:31
아니 일단 기준을 잡아봐 극단적인 성능만 포커스를 두고 하지 말라는 얘기야

참석자 1 1:09:40
아니죠. 어차피 한 번 이렇게 다 도는데 거기서 내가 실제로 그 안에서 라이프 사이클을 만들어주는 거죠.
실제로 나 이거 생성했어. 그럼 너가 하고 싶은 거 해.
이제 노드 수집하고 싶으면 수집하고 프로드바이더 하고 싶으면 하는 거고 플로그인하고 싶으면 하는 거고 그 시점에서 해줄 수 있는 건데 이제 이것도 그냥 딱 빼버리면은 나는 실제로 ast만 만들 거야 하고 쫙 만드는 거 그리고 나 다 만들었으니까 그다음에 이제 그다음 라이프 사이클 뭐야 노드 수집하는 거야 또 한 번 돌아가지고 노드 수집해.
이렇게

참석자 2 1:10:12
어디 쓰지 아니면 뭐

참석자 1 1:10:17
되는 건지가 궁금해서

참석자 2 1:10:36
지금은 여기까지 가지 마라. 지금 이 얘기를 하는 건 건데 이 얘기를

참석자 2 1:10:46
이렇게 해 더 돌아가 일단 네네네 오케이

참석자 2 1:10:57
그거 뭐 루프 몇 번 도는 거

참석자 2 1:11:06
일단 지금 있는 관리가 너무 안 돼. 지금 당장 5.6 애들 지금 시가 반응이 뭐냐면 너무 많이 그냥 똑같이 복사되고 있어.
지금 구조가 근데 이거 계속 반복돼 학계 소개 이거 언제까지 개발할 거야?
계속 인쇄 감당 못해 나중에 이거 계속 바뀌면 일단 내가 볼 때는 그 정도 비용은 감소한다.
다른 걸로 커버하면 돼. 그러니까 그런 시간까지 그러니까 뭔가 확장성을 선택을 하는 게도 있고 대신에 다른 걸로 그거를 만회하면 되는

참석자 2 1:12:03
됐나 그러면 일단 이번 주까지 아까 얘기한 거 다시 그러니까 이번 주까지 할 거만 다시

참석자 2 1:12:21
12월까지 승현이는 승현이 거는 얼마나 된 거야 지금 어쨌든 승현이 거 확인해야 돼.
근데 저거 안 되는데 개발 방에서 나오나

참석자 1 1:12:39
일단 데이터 연동하는 거 빼고 하면 되니까요. 그렇게 하겠습니다.
이거 어떤 파일 만들어야 되고 어디 가서 어떤 파일 만들어야 되고 뭐 해야 되고 뭐 해야 되고 이런 거만 써놓은 거

참석자 2 1:12:51
일단 잠깐 시간 목요일 날 오전에 한번

참석자 2 1:13:13
일단 소스 푸시 돼 있나 네

참석자 1 1:13:29
왜

참석자 4 1:13:33
그럼 플로그인 프로바이더가 노드 프로바이더 모르게 그냥 따로 돌아야겠네요.

참석자 1 1:13:37
아마 지금 아마 다섯 여섯 개 다 돌려야 될 것 같아요.
그냥 따로따로 말씀하시는 거는 그렇게 돌리라고 하니까

참석자 6 1:13:47
토요일 날 와서 이 구조만 다 봤는데 구조가 다 바뀐 거 없네.

참석자 1 1:13:52
좀 먹어 봐.

참석자 6 1:13:53
저는 5.0이랑 어떻게 연결되어 있나 다

참석자 1 1:13:57
여기가 많이 여기 영향을 많이 받아서 여기가 바뀌지 어떻게 되느냐에 따라서 나머지가 또 영향을 받을 수 지금은 완전 5.0 세개만 있는 거라서 양쪽에 근데 원 사이클로 돌게끔 해놨는데 원 사이클이 아니라 지금은 이제 각 개별로 돌게끔 해달라고 하시는 거고 그리고 근데 그거는 하나 정해줘야 되는 거죠.
제네레이터를 밖에 지금 써도 되는지 그거는 아마 내일 한 번 다시 물어봐야 될 것 같아요.

참석자 7 1:14:27
한번 포이스를 보시면

참석자 4 1:14:29
근데 제너리트를 그러니까 지금 밖으로 빠져나와 있다고 생각하시는 거고 저거를 플렉션 안에다 넣자라는 말씀이신데 그럼 플렉션이 아이 셀럽에 대한 막 어트렉티드를 다 받아야 되는 상황이

참석자 1 1:14:43
그래서 제가 아까 그래서 그럼 다섯 단계가 있으실 건데 그게 1 2 3단계에 어느 순간에는 결국에는 아예 셋업이 들어갈 거 그러니까 이 데이터 타입이 들어갈 거다라고 말씀을 드렸는데 그거를 이제 말씀해 주신 거는 그거를 그냥 제네릭으로 해서 실제로 외부가 그걸 정할 거다.
아웃풋은 어차피 얘가 플렉션이 받아서 가야 되고 그다음 단계가 받아서 가야 되니 걔는 플렉션 as로 정해져 있는 거고 인풋은 그 사람이 정해서 넣었으니 어차피 콜백으로 해서 다시 바로 그 밖으로 빠져나갈 거다.

참석자 4 1:15:16
그럼 최소한의 제너레이터 로직은 일단 erpi는 살아는 있어야 되는

참석자 1 1:15:19
그렇게 될 것 같아요. 저거 제네릭터는 있을 것 같아요.
ERP

참석자 4 1:15:24
뭔가 뷰 단에 큰 변동이 있는 것들을 다 이제 컬렉션에서 하고 최소한의 필요한 정보들은 ERP에서 손질해서는 줘야 되고

참석자 1 1:15:33
그럴 것 같아요. 그 외부 단계들을 여기에서 뭔가 주입을 하긴 하는데 실제로 행위를 하는 애들은 다 밖에 존재할 것 같기는

참석자 1 1:15:49
그러니까 그래서 지금이랑 뭐가 다르지 근데 약간 아까 뭐 생각해 보면은 소개할게 뭐 이런 애들 인쇄 뭐 여러 가지들 이런 것들을 작업하기 전에 뭔가 asd로 일반화를 시켜놓고 그러니까 제3 세계에 있는 데이터를 asd로 뭔가 일반화를 시켜놓고 그걸 가지고 얘네를 다시 한번 만들고 싶다 인 것 같아요.

참석자 3 1:16:19
똑같은 astl을

참석자 1 1:16:21
아니 똑같은 이거 왜냐하면 이 ast를 가지고 이제 만들어내는 거는 어차피 한 번만 작업하면 되니까 지금 한 번 작업하면 되는데 지금 이제 반대로 생각해서 인풋이 되는 애를 가지고 나는 지금은 가공을 하고 있단 말이야.
현재 5.0 그러니까 이게 5.6이 되면 또 이걸 또 가공을 해야 돼.
걔에 맞춰서 소개 페이지 바켓이 또 작업을 해야 돼 다 그러니까 이제 ASP로 아예 만들자 이거지 데이터를 ast로 만들고 소개 페이지로 이 모든 것들을 다 ast로 하는 걸로 하자.
그러면 이거는 이제 한 번만 하면 되지 않냐라고 말씀하시는

참석자 6 1:16:56
하나로 모으자.

참석자 1 1:16:57
ast라는 그냥 그 타입으로 그냥 이제 끝내자 이거를 말씀하시는 거예요.

참석자 4 1:17:04
지금 우리가 만들고 있는 플로우 ST를 플렉션 안에서 만들자는 거죠.
결국에는

참석자 1 1:17:09
플로우 ast를

참석자 4 1:17:13
저희는 플로우에스티가 결과물라고 생각하잖아요.
바로 보여질 거 그걸 플렉션 안에서 하자. 데이터 ast가 넘어오는 거고 어플렉션은 어플렉션 안에서는 실제 네 그 ast

참석자 1 1:17:27
그러니까 한 번 더 가공하는 작업이 있는 거야. 아이 셋업 가지고 뭔가 만든 거는 외부에서 이제 아이 셋업이 이런 모습 플렉션은 이제 이런 모습이야라고 딱 알려주고 부가적인 정보들은 또 여기서 또 한 번 가공하는 작업도 있고 싶으신 것 같아요.
지금 저는 약간 그럴 생각은 아니긴 했는데 그래서 좀 더 봤어요.
좀 있으면 이제

참석자 6 1:17:55
5.6이 그런 형태 아니었어요. 하나 ast로 몰아서 다 만들고

참석자 1 1:18:03
그치 NST 다 몰긴 하는데 나 5.6 콘셉트이었던 것 같은데 맞아 오케이 왜냐하면 5.6으로 해야 되니까 5.6으로 가야 되니까 그렇게 하시는 것 같은데 모르겠습니다.

참석자 1 1:18:30
제가 이해하는 게 맞는지 모르겠어. 말씀해 주세요.
부문장님이 원하시는 게 어쨌든 저희가 최종적으로 다루는 노드 ast 노드잖아요.
그래서 각 타입별로 ast 노드가 있으니까 그걸 만들어 놓고 그리고 저희가 이제 부가적으로 기능들을 이제 넣을 거잖아요.
그런 것들을 이 ast 노드를 가지고 이제 컨트롤하자 맞아 약간 이런 의미인 거죠.
맞아 그러면 한 번 컨트롤한 게 있으면 그 명칭만 5.6을 하든 뭘 하든 갈아끼기만 하면 되니까 거 기에 맞춰서 그렇죠 그렇죠 그렇죠 그렇게 말씀을 하시네요.

참석자 1 1:19:08
대표

참석자 1 1:19:15
이것도 되죠. ast 데이터가 왜냐하면 모든 로직이 다 데이터가 변함으로 인해서 다시 한 번 작업하는 게 대부분이라서

참석자 1 1:19:35
저는 에니스트로 못 들고 올 텐데 에니스트로 절대 못 들고 갈 에이스를 들고 올 수가 없어.

참석자 1 1:19:51
저는

참석자 1 1:19:57
그 구조를 벗어날 수 있는데 한번 잘 생각해 가지고

참석자 4 1:20:17
약간 찝찝한 건 너무 데이터스러운 정보들이 플렉션까지 넘어가는 거 그러니까 그게 조금 치질이요.
그러니까 의도는 알겠어요. 의도는 좋은 것 같아요.
버전이 바뀌에 따라서 이 하나만 딱 세팅해 주면 끝이니까 근데 너무 많은 정보들이 일로 넘어가는데 UI 받는 대로 보여줘야 될 애가 데이터 가공을 또 한 번 더 해주는 플렉션 하는 역할이 맞을까

참석자 2 1:20:42
그러니까

참석자 7 1:20:44
절대 못 가요. 난

참석자 4 1:20:51
ERP 플렉션이 돼버리는 느낌.

참석자 1 1:20:57
그렇죠 이게 그렇게 하려면 방법은 있긴 한데 보고 있긴 해.

참석자 1 1:21:15
그렇게 하려면은 그러니까 저도 이제 좀 전에 이렇게 계속 말을 하려다 안 하는 게 저는 당연히 안 된다고 생각하거든요.
왜냐면은 지금의 5.0이든 그러니까 어느 프로그램을 만들든 디피니션이랑 결국엔 데이터는 필요해요.
이 두 개 왜냐하면 두 개를 매칭을 해야 뭔가 아웃풋을 주니까 그리고 거기에 부가적으로 있는 게 지금 뷰 컨테이너에 있는 어트리프트들이란 말이에요.
왜냐하면 실제로 내가 이 하나의 뭉탱이에 어떤 기능들을 쓸 거야 말 거라는 거는 디펜션이나 데이터 모델을 정의를 할 수가 없어요.
그래서 제3의 나 어떤 기능들을 쓰고 있어 나 이런 어떤 항목들을 어떻게 세팅할 거야 이 정보들을 다 여기 뷰 컨테이너가 다 이걸 제어를 해주고 있는데 얘네가 세 개가 잘 맞물려 가지고 이제 뭔가 소개든 뭐든 다 해주고 있는 거란 말이에요.
근데 일단은 플렉션으로 그걸 맞는 순간 사라져요.
얘네들이 아니면 제3 세계다 막 이렇게 넌 모델이야 넌 디펜션이야 넌 속성 정보야 어떤 거 쓸 거야?

참석자 1 1:22:18
결국엔 어디다 짱 박아야 돼 그게 짱 맞고 결국엔 이 ast 만든 거를 이걸 다시 가져와가지고선 뭔가 재가공해 주는 이런 행위를 해야 된다고 저는 생각을 해서 절대 불가능하다라고 저는 단형 컨데 얘기할 수 있는데 그건 저만의 또 생각이라고 저는 생각이 들어서 자꾸 얘기를 안 하려고 했던 거였거든요.

참석자 4 1:22:38
불가능인가요?

참석자 1 1:22:39
불가능해요. 그건

참석자 4 1:22:40
데이터를 그냥 다 준다 치면은 또 가능한 건

참석자 1 1:22:44
가능하게 그래서 절대 불가능인데 이거를 가능하게 해 줄 수는 있어요.
다 맵을 만들어주면 돼요. 뷰 컨테이너에 있는 이 어트리부트는 실제 우리 세계에서 쓸 때는 어떤 이 어트리부트 정보를 가지고 해야 돼?
나는 이거야. 그러면 매몰 딱 찾아서 너 이거 있어 그러면 딱 뽑아서 그냥 쓰면 돼.
왜냐하면 이 데이터 유형이 바뀌지 않는다라는 전제하에 내가 쓸 수 있는 데이터 유형은 절대 바뀌면 안 돼.
그럼 얘가 맞춰줘야 돼요. 너 실제로 나는 너 이걸 딱 가져갔을 때 난 숫자형이어야 되는데 너 문자형이네.
그럼 너 틀렸어 네가 틀린 거야 내가 틀린 거 아니야 너네 세계에서 이거를 재가공함으로 인해서 비용이 드는 건 너네 잘못이야.
우리 잘못은 아니야. 그러면은 이 매핑만 해줄 수 있는 정보만 탁 넣을 수 있게끔 얘한테 플렉션에서 해주면 다 필요 없어요.
그냥 만들 수 있어요.

참석자 1 1:23:35
얘는 왜냐하면 모델 모델은 실제로 내가 바라봐야 되는 모델은 너네가 넘겨주는 거에 어디에 속해 있어 이런 것들을 딱 맵만 알려주면 되거든.
그럼 비용이 안 들어. 근데 이걸 안 하면 비용을 엄청 많이 들여서 가지고 와야 돼 이걸 인식시켜줘.
그래서 이제 절대 불가능이라고 하는 게 이 인식시키는 비용을 쓸 거면 안 하는 게 나아서 근데 만약에 그렇게 굳이 그렇게 하겠다 그러면 맵 정보를 만들어서 주입을 해줘야 되는 거죠.

참석자 4 1:24:06
그 앱 정보는 버전이 달라짐에 따라서 불변화나

참석자 1 1:24:10
얘는 불변이죠. 얘가 가져오는 건 불변인데 얘는 변할 수 있겠죠.
그쵸

참석자 4 1:24:14
얘가 이 맵 정보로 똑같이 해주기 위한 가공은 해야 되는 거고요.

참석자 1 1:24:19
가공은 안 하죠. 왜냐하면 여기서 딱 그 빼내는 순간에 그 맵을 보고 얘를 딱 잡아서 끄집어 와야 돼서 안 그러면은 결국엔 가공하는 거랑 똑같거든요.
이거 가공해서 넣어주는 거랑 내가 맵을 찾아서 저기 가서 가공해서 오는 거랑 다를 게 없어요.
근데 약간 어떻게 보면은 처음 말한 거는 처음부터 다 가공을 해야 되니까 비용이 많이 들 수 있는데 여기서 했을 때 얘가 가공을 할 수 있겠죠.
그럼 그 시점에만 딱 가공하면 되니까 대신에 분산해서 가공을 하는 것뿐이거든요.
이게 처음에 가공하는 거랑 내가 딱 부르는 시점에 가공 한 번 하는 거랑 이건 좀 달라질 수는 있겠죠.
이렇게 하면은 가능은 하긴 해요. 저 말씀하신 거 근데 이 ast를 바꾸고 그거에 대해서 뭔가 더 뒷 백단에서 더 해 갖고 ast 다시 생성해야 된다.
이거는 저는 안 하고 싶은 개인적으로는 저는 하실 수 있겠어요.
왜냐하면 말씀하신 대로 결국에는 다 해줄 수는 있어요.

참석자 1 1:25:28
근데 저는 약간 실패하는 프로젝트를 하고 싶지는 않거든요.
실패 벌써 노여있는데 실패해 벌써 실패했다 이게 나중에 우리가 60% 70% 80% 갔을 때 마지막 90% 가산제로 런칭하려고 했을 때 테스트까지 다 했어 런칭하려고 하는데 야 이거 해결 안 되면 안 돼라는 말이 저는 분명히 나올 것 같아서 그러면 이제 약간 저는 그냥 약간 프로젝트 빼달라고 하거든요.
왜냐하면 내가 생각하는 리스크가 있으니까 나도 그래서 아까 이제 되게 어떻게 보면 약간 좀 디테일하게 물어본 게 어느 단계에서 어떻게 할 거냐 이런 걸 물어본 게 그거에 따라서 어디까지 작업하는지가 나올 거다 그랬는데 제 생각이 다 맞는 건 아니니까 또 생각하시는 것들이 있을

참석자 1 1:26:36
그래서 제가 이게 제네리터를 제가 아까 5.0에다 넣어놓은 이유는 딱 그거예요.
커맨드로 결국에는 날아올 거거든요. 밖으로 그냥 딱 스크롤 탁 하는 순간 코멘드로 밖으로 탁 튕겨낼 거예요.
얘가 그러면은 실제로 내가 스타트 인덱스랑 앤드 인덱스를 그쪽에서 계속 밖으로 튕겨주면 어차피 자바스크립트는 되게 빨리 이벤트를 발생시키니까 다 받을 수는 없어요.
그래도 디바스나 해서 5초에 한 번씩 오던가 300m 스톤에 한 번 오던가 해서 하면은 결국에는 이제 데이터를 끌고 다시 들어갈 수는 있어요.
그런 의도 때문에 얘를 밖에다 놓은 거였고 그리고 제가 아까 서두에 말씀드렸는데 5.0에 얘가 없었으면 좋겠다 도 그 이유 중에 하나지 왜냐하면 이제 종속되어 버린 상황이라서 아이 셋업에 결국에 종속될 수밖에 없긴 하겠지.
얘도 얘도 프레임웍이라고 만들어 놓은 아이인데 결국에는 뭔가 5.0에 지금 종속돼 있잖아요.
그래서 그래서 그것도 좀 빼주십사라고 그런 의도에서 얘기했던 거였는데

참석자 4 1:27:54
그럼 이런 일은 어디로 빠지면 돼요?

참석자 1 1:27:56
그냥 저희 이렇게 프로젝트처럼 밖으로 빠져 있는 거죠.
그래서 5.0에다 그냥 주입해 주는 방식으로 그럼 5.0이 실제로 내가 제3세계 플렉션이랑 연결이 됐네.
연결이 됐으면 내가 지금 데이터 쓰는 데는 얜데 그럼 제3 세계에다 여기다가 알려주면 얘가 다 제너레이팅 해 주고 결국엔 똑같은 거 할 거거든요.
아이 세드로 들어왔으니까 자기가 아이 세드 파싱하겠지 템플릿 왔으니까 템플릿 파싱 하겠지 약간 이런 식으로 해서 얘는 중간다리 역할만 해 주기를 원했던 입장에서 약간 얘기를 했던 거 같아.
근데 그거는 뭐 해도 되고 안 해도 되는 그런 부분이라서 얘가 들어가도 상관은 없어요.
밖에 있어도 상관없는

참석자 4 1:28:45
이번 주에 하라고 하시는 게 그 테스트 환경이잖아요.
그럼 그거는

참석자 1 1:28:51
그건가요? 네 개발 요거 개발

참석자 4 1:28:53
환경이 그러면은 나오면 미정 님이 나오면 그거 가지고 각 패키지별로 적용을 저희가 따로 해야 된다는 거죠.
패키지별로 네 그런 말씀 아니

참석자 1 1:29:05
그렇죠 그렇죠 그렇죠 그렇죠 그래서 아마 그래서 이렇게 나눠놓은 저도 그런 의도에서 이렇게 나눈 거거든요.

참석자 3 1:29:12
개발 환경은 테스트해 봐요. 환경

참석자 1 1:29:15
그치 그치 플레이 그라운드 실제로 내가 이걸 만들었으면은 어떻게 해야 이 환경에 들어가고 이 환경에서 어떻게 보면 개발할 수 있는지 확인할 수 있는지 여기서 개발을 하면 실제로 어떤 기능들을 넣고 싶으면 플로그인을 어떻게 만들어야 되고 아까

참석자 4 1:29:36
그런 말씀하신 것 같아서 기능별로 그것만 돌게 해야 된다.
그게 플레이 그라운드 말씀

참석자 3 1:29:41
그렇죠 맞아 맞아 하나의 항목이 이제 돌아갈 때

참석자 1 1:29:46
항목이든 어떤 기능이든 결국에는 플러그인이든 어떤 프로바이드든 이렇게 주입을 해 주면 그거에만 이렇게 이제 테스트할 수 있는

참석자 4 1:29:58
그럼 저도 또 추가로 할 게 있을까요?

참석자 1 1:30:01
추가로 해야 될 거는 일단 아까 그거를 그거를 그냥 좀 봐주셨으면 좋겠어요.
아까 제네레이터 있잖아요. 제너레이터가 그럼 이제 테이블 2개 3개 현황에서 만들 수 있는 그런 환경이 지금 환경에서도 가능하냐 지금 환경에서 불가능하면 어떻게 해야지 가능하냐 저는 되게 단순하게 생각하고 있었어 가지고 계속할 수 있어.
말 그대로 그냥 컴포넌트 반복하는 거지 단순하죠.
저도 약간 근데 거기 들어가는 데이터가 달라져서 그런 거라서 아마 약간 근데 그걸 벌써 다 결정 지었어요.
그게 딱 제너 자기한테 오는 순간 다 결정 지어서 올 수밖에 없고 그럴 수밖에 없는 뭘 해도 그렇게밖에 못해서 그냥 제너레이터 단계에서 자기가 나 이거 할 거야 저거 할 거야 갑자기 거기서 뭔가 바꿔치기 할 수도 있거든요.
앞단에서 다 하고 와야지 지금도 그러고 있고 예전에도 그렇고

참석자 4 1:31:11
근데 지금 딴 얘기인데 렉시컬 컬렉션 컨텍스트 컴퍼넌트 있잖아요.
거기 이니셜 콤피그 받고 하나 있죠. 네 저희 폼이랑 그리드 있는데 각각 타거든요.

참석자 1 1:31:25
각각 타게 해놨어요. 일부러 그래서 그때 아마 말씀하셨던 게 저번 회의 때 말씀하셨던 게 원래 전 전 회의 때는 각각 타게 해달라 그래서 전 회의 때는 둘 다 하게 해달라 라고 해서 그러면 그렇게 하려면 이거 지금 제너레이터랑 컴포넌트랑 이런 거 다 옮겨야 된다.
의존성 왜냐하면 지금 그게 의존성 때문에 그렇게 만들 수밖에 없는 상황이라서

참석자 4 1:31:50
그럼 각각 산다는 건 각각이 플렉션이라는 각각의 에디터라는 거죠.
그쵸 네네

참석자 1 1:31:55
현재는 그렇게 돼 있어요.

참석자 1 1:32:01
또 궁금한 게 최종적인 목표는 컴포넌트 단에서 조금 수정을 다시 하는 게 목표인가요?
아니면 컴포넌트는 그냥 그대로 이식을 하는 건가요?
컴포넌트는 그 1차적으로는 컴포넌트를 그대로 이식을 하는데 지금 거기에 불필요한 데이터들이 있어요.
데이터나 색 데이터나 밸리데이터 하는 데도 불편할 수도 있고 이런 불필요한 애들은 일단 제거하는 게 최종 목표고

참석자 4 1:32:27
근데 그거 연장선으로 그리드 컴퍼넌트 같은 경우는 이 시그리드 컴퍼넌트가 모든 애들을 지금 다 관할하잖아요.
근데 얘는 재사용이 얘도 재사용 대상인가요? 아니요.
그거는 그렇죠 걔네는 지금 생자 다시 개발인 거죠.

참석자 1 1:32:43
그렇기는 해요. 제가 알기로는 근데 그래서 기간이 되게 많다라고 선 느끼시는 게 그대로 가지고 온다라고 생각하고 계셨으면은 많이 걸린다라고 생각 안 하셨을 것 같아요.

참석자 4 1:33:02
그러니까 애초에 상속도 엘리먼트 노드부터 상속을 받아버렸잖아요.
테이블이 그러니까 각각이 관리하는 이제 뭔가로 바뀌는

참석자 1 1:33:11
그거를 라이트하게 가져가고 싶으신 것 같아요. 지금은 리액트다 보니까 주입을 하면 이제 다 찾는 로직이 있어서 그게 뭐 리액트니까 또 그래서 그렇게 얘기하시는 겁니다.

참석자 4 1:33:29
EC 코드 같은 경우는 거의 그대로 가는 거

참석자 1 1:33:31
그렇죠 대부분은 그냥 말단에 있는 데는 일단은 다 들고 와야 되고 근데 이제 사라지는 애들이 있겠죠.
왜냐하면 DMC가 이제 본 세계는 없으니까 그런 것들은 이제 좀 빼는 작업도

참석자 3 1:33:50
빼는 거 보려고 그 데이트 컴포넌트 하고 있었는데 이게 저 테스트 환경에서 모듈 불러오는 것 때문에 시간을 좀 많이 잡아먹었어요.
그래서 저건 아직 못했는데 저것보다는 개발 환경 먼저 하는 게 맞겠죠.

참석자 1 1:34:05
근데 그게 안 되면 개발 환경이 안 되는 거 아니야

참석자 3 1:34:09
따로따로 할 수 있긴 해요.

참석자 2 1:34:13
바로 어디를 못 불러온다

참석자 3 1:34:19
지금 모듈 패키지 같은 거 있잖아요. 이제 이 카운 지금 이제 5.0에서 사용하고 있는 익스터널에서 사용하고 있는 외부 라이브러리들이 있잖아요.
그런 거 지금 불러오는 게 문제 있어가지고 조금 더디고 있습니다.

참석자 1 1:34:37
그건 다 죽을 거라고

참석자 3 1:34:39
주소요 그냥 주소고요. 있어

참석자 1 1:34:41
정말은 다 추적하려고 그게 뭐 중요한 건 아니니까 익스트널이 중요한 건 아니야 중요한 그 모듈일 뿐이지 중요한 게 아니라서 왜냐면 나중에 그걸 옮겨와도 되니까 아마 컴포넌트 만드는 데는 익스터널이 거의 안 쓸 텐데

참석자 3 1:35:03
UA 킷에서 거의 다 사용하고

참석자 1 1:35:05
UI 킷에서 익스턴으로 사용한다고

참석자 3 1:35:08
네 잠깐 봤었는데 차트나 도형 같은 거

참석자 1 1:35:15
아니면은 없어 그런 거 없어요.

참석자 3 1:35:18
일단 다 그냥 주소

참석자 1 1:35:19
차트 도형 그런 거는 컴포넌트 안에 없어 있긴 있는데 그건 진짜 차트 전용으로만 쓰고 있어서 그냥 그럼 래핑돼 있는 걸까요?
그 녀석이 이스터너를 래핑해버렸어. 왜냐하면 걔가 HTML이거든요.
HTML이거나 SVG거나 이래서 해서 매핑 했어요.
다 줘서

참석자 7 1:35:50
신경 쓰지 마 알겠습니다. 일단 됐다 이거 그대로

참석자 6 1:35:59
잘 부탁드리겠습니다. 저 내일 인수인계 받으면 되나요?

참석자 1 1:36:09
너 승현이랑

참석자 6 1:36:11
오늘 안 오셔가지고 저 혼자 그냥 보다가 오늘 그냥 얘기했던 거 다

참석자 2 1:36:18
봤던 거더라고요. 토요일 날

참석자 1 1:36:21
별 거 없어 그래서 별거 다 어 구조적으로

참석자 1 1:36:31
해주셨죠.


clovanote.naver.com