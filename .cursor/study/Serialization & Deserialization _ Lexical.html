<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="serialization-deserialization">Serialization &amp; Deserialization</h3>
<p>
  Internally, Lexical maintains the state of a given editor in memory, updating
  it in response to user inputs. Sometimes, it&#39;s useful to convert this
  state into a serialized format in order to transfer it between editors or
  store it for retrieval at some later time. In order to make this process
  easier, Lexical provides some APIs that allow Nodes to specify how they should
  be represented in common serialized formats.
</p>
<h4 id="html">HTML</h4>
<p>
  Currently, HTML serialization is primarily used to transfer data between
  Lexical and non-Lexical editors (such as Google Docs or Quip) via the copy
  &amp; paste functionality in @lexical/clipboard, but we also offer generic
  utilities for converting Lexical -&gt; HTML and HTML -&gt; Lexical in our
  @lexical/html package.
</p>
<h5 id="lexical-html">Lexical -&gt; HTML</h5>
<p>
  When generating HTML from an editor you can pass in a selection object to
  narrow it down to a certain section or pass in null to convert the whole
  editor. import { $generateHtmlFromNodes } from &#39;@lexical/html&#39; ; const
  htmlString = $generateHtmlFromNodes ( editor , selection | null ) ;
</p>
<h6 id="lexicalnode-exportdom">LexicalNode.exportDOM()</h6>
<p>
  You can control how a LexicalNode is represented as HTML by adding an
  exportDOM() method. exportDOM ( editor : LexicalEditor ) : DOMExportOutput
</p>
<p>
  When transforming an editor state into HTML, we simply traverse the current
  editor state (or the selected subset thereof) and call the exportDOM method
  for each Node in order to convert it to an HTMLElement . Sometimes, it&#39;s
  necessary or useful to do some post-processing after a node has been converted
  to HTML. For this, we expose the &#34;after&#34; API on DOMExportOutput ,
  which allows exportDOM to specify a function that should be run after the
  conversion to an HTMLElement has happened. export type DOMExportOutput = {
  after ? : ( generatedElement : ? HTMLElement ) =&gt; ? HTMLElement , element ?
  : HTMLElement | null , } ;
</p>
<p>
  If the element property is null in the return value of exportDOM, that Node
  will not be represented in the serialized output.
</p>
<h5 id="html-lexical">HTML -&gt; Lexical</h5>
<p>
  import { $generateNodesFromDOM } from &#39;@lexical/html&#39; ; editor .
  update ( ( ) =&gt; { // In the browser you can use the native DOMParser API to
  parse the HTML string. const parser = new DOMParser ( ) ; const dom = parser .
  parseFromString ( htmlString , textHtmlMimeType ) ; // Once you have the DOM
  instance it&#39;s easy to generate LexicalNodes. const nodes =
  $generateNodesFromDOM ( editor , dom ) ; // Select the root $getRoot ( ) .
  select ( ) ; // Insert them at a selection. $insertNodes ( nodes ) ; } ) ;
</p>
<p>
  If you are running in headless mode, you can do it this way using JSDOM:
  import { createHeadlessEditor } from &#39;@lexical/headless&#39; ; import {
  $generateNodesFromDOM } from &#39;@lexical/html&#39; ; // Once you&#39;ve
  generated LexicalNodes from your HTML you can now initialize an editor
  instance with the parsed nodes. const editorNodes = [ ] // Any custom nodes
  you register on the editor const editor = createHeadlessEditor ( { ... config
  , nodes : editorNodes } ) ; editor . update ( ( ) =&gt; { // In a headless
  environment you can use a package such as JSDom to parse the HTML string.
  const dom = new JSDOM ( htmlString ) ; // Once you have the DOM instance
  it&#39;s easy to generate LexicalNodes. const nodes = $generateNodesFromDOM (
  editor , dom . window . document ) ; // Select the root $getRoot ( ) . select
  ( ) ; // Insert them at a selection. const selection = $getSelection ( ) ;
  selection . insertNodes ( nodes ) ; } ) ; tip Remember that state updates are
  asynchronous, so executing editor.getEditorState() immediately afterwards
  might not return the expected content. To avoid it, pass discrete: true in the
  editor.update method.
</p>
<h6 id="lexicalnode-importdom">LexicalNode.importDOM()</h6>
<p>
  You can control how an HTMLElement is represented in Lexical by adding an
  importDOM() method to your LexicalNode . static importDOM ( ) :
  DOMConversionMap | null ;
</p>
<p>
  The return value of importDOM is a map of the lower case (DOM) Node.nodeName
  property to an object that specifies a conversion function and a priority for
  that conversion. This allows LexicalNodes to specify which type of DOM nodes
  they can convert and what the relative priority of their conversion should be.
  This is useful in cases where a DOM Node with specific attributes should be
  interpreted as one type of LexicalNode , and otherwise it should be
  represented as another type of LexicalNode . type DOMConversionMap = Record
  &lt; string , ( node : HTMLElement ) =&gt; DOMConversion | null
</p>
<blockquote>
  <p>
    ; type DOMConversion = { conversion : DOMConversionFn ; priority : 0 | 1 | 2
    | 3 | 4 ; } ; type DOMConversionFn = ( element : HTMLElement ) =&gt;
    DOMConversionOutput | null ; type DOMConversionOutput = { after ? : (
    childLexicalNodes : Array &lt; LexicalNode &gt; ) =&gt; Array &lt;
    LexicalNode &gt; ; forChild ? : DOMChildConversion ; node : null |
    LexicalNode | Array &lt; LexicalNode &gt; ; } ; type DOMChildConversion = (
    lexicalNode : LexicalNode , parentLexicalNode : LexicalNode | null |
    undefined , ) =&gt; LexicalNode | null | undefined ;
  </p>
</blockquote>
<p>
  @lexical/code provides a good example of the usefulness of this design. GitHub
  uses HTML
</p>
elements to represent the structure of copied code in HTML. If we interpreted
all HTML
<table></table>
elements as literal tables, then code pasted from GitHub would appear in Lexical
as a Lexical TableNode. Instead, CodeNode specifies that it can handle
<table></table>
elements too: class CodeNode extends ElementNode { ... static importDOM ( ) :
DOMConversionMap | null { return { ... table : ( node : Node ) =&gt; { if (
isGitHubCodeTable ( node as HTMLTableElement ) ) { return { conversion :
convertTableElement , priority : 3 , } ; } return null ; } , ... } ; } ... }
<p></p>
<p>If the imported</p>
<table></table>
doesn&#39;t align with the expected GitHub code HTML, then we return null and
allow the node to be handled by lower priority conversions. Much like exportDOM
, importDOM exposes APIs to allow for post-processing of converted Nodes. The
conversion function returns a DOMConversionOutput which can specify a function
to run for each converted child (forChild) or on all the child nodes after the
conversion is complete (after). The key difference here is that forChild runs
for every deeply nested child node of the current node, whereas after will run
only once after the transformation of the node and all its children is complete.
<p></p>
<h5 id="html-property-for-import-and-export-configuration">
  html Property for Import and Export Configuration
</h5>
<p>
  The html property in CreateEditorArgs provides an alternate way to configure
  HTML import and export behavior in Lexical without subclassing or node
  replacement. It includes two properties: import - Similar to importDOM , it
  controls how HTML elements are transformed into LexicalNodes . However,
  instead of defining conversions directly on each LexicalNode , html.import
  provides a configuration that can be overridden easily in the editor setup.
  export - Similar to exportDOM , this property customizes how LexicalNodes are
  serialized into HTML. With html.export , users can specify transformations for
  various nodes collectively, offering a flexible override mechanism that can
  adapt without needing to extend or replace specific LexicalNodes .
</p>
<h6 id="key-differences-from-importdom-and-exportdom">
  Key Differences from importDOM and exportDOM
</h6>
<p>
  While importDOM and exportDOM allow for highly customized, node-specific
  conversions by defining them directly within the LexicalNode class, the html
  property enables broader, editor-wide configurations. This setup benefits
  situations where:
</p>
<ul>
  <li>
    <strong>Consistent Transformations</strong>
    : You want uniform import/export behavior across different nodes without
    adjusting each node individually.
  </li>
  <li>
    <strong>No Subclassing Required</strong>
    : Overrides to import and export logic are applied at the editor
    configuration level, simplifying customization and reducing the need for
    extensive subclassing.
  </li>
</ul>
<h6 id="type-definitions">Type Definitions</h6>
<p>
  type HTMLConfig = { export ? : DOMExportOutputMap ; // Optional map defining
  how nodes are exported to HTML. import ? : DOMConversionMap ; // Optional
  record defining how HTML is converted into nodes. } ;
</p>
<h6
  id="example-of-a-use-case-for-the-html-property-for-import-and-export-configuration">
  Example of a use case for the html Property for Import and Export
  Configuration:
</h6>
<p>Rich text sandbox</p>
<h5 id="handling-extended-html-styling">Handling extended HTML styling</h5>
<p>
  Since the TextNode is foundational to all Lexical packages, including the
  plain text use case. Handling any rich text logic is undesirable. This creates
  the need to override the TextNode to handle serialization and deserialization
  of HTML/CSS styling properties to achieve full fidelity between JSON &lt;-&gt;
  HTML. Since this is a very popular use case, below we are proving a recipe to
  handle the most common use cases. You need to override the base TextNode:
  const initialConfig : InitialConfigType = { namespace : &#39;editor&#39; ,
  theme : editorThemeClasses , onError : ( error : any ) =&gt; console . log (
  error ) , nodes : [ ExtendedTextNode , { replace : TextNode , with : ( node :
  TextNode ) =&gt; new ExtendedTextNode ( node . __text ) , withKlass :
  ExtendedTextNode , } , ListNode , ListItemNode , ] } ;
</p>
<p>
  and create a new Extended Text Node plugin import { $applyNodeReplacement ,
  $isTextNode , DOMConversion , DOMConversionMap , DOMConversionOutput , NodeKey
  , TextNode , SerializedTextNode , LexicalNode } from &#39;lexical&#39; ;
  export class ExtendedTextNode extends TextNode { constructor ( text : string ,
  key ? : NodeKey ) { super ( text , key ) ; } static getType ( ) : string {
  return &#39;extended-text&#39; ; } static clone ( node : ExtendedTextNode ) :
  ExtendedTextNode { return new ExtendedTextNode ( node . __text , node . __key
  ) ; } static importDOM ( ) : DOMConversionMap | null { const importers =
  TextNode . importDOM ( ) ; return { ... importers , code : ( ) =&gt; ( {
  conversion : patchStyleConversion ( importers ?. code ) , priority : 1 } ) ,
  em : ( ) =&gt; ( { conversion : patchStyleConversion ( importers ?. em ) ,
  priority : 1 } ) , span : ( ) =&gt; ( { conversion : patchStyleConversion (
  importers ?. span ) , priority : 1 } ) , strong : ( ) =&gt; ( { conversion :
  patchStyleConversion ( importers ?. strong ) , priority : 1 } ) , sub : ( )
  =&gt; ( { conversion : patchStyleConversion ( importers ?. sub ) , priority :
  1 } ) , sup : ( ) =&gt; ( { conversion : patchStyleConversion ( importers ?.
  sup ) , priority : 1 } ) , } ; } static importJSON ( serializedNode :
  SerializedTextNode ) : TextNode { return $createExtendedTextNode ( ) .
  updateFromJSON ( serializedNode ) ; } isSimpleText ( ) { return this . __type
  === &#39;extended-text&#39; &amp;&amp; this . __mode === 0 ; } // no need to
  add exportJSON here, since we are not adding any new properties } export
  function $createExtendedTextNode ( text : string = &#39;&#39; ) :
  ExtendedTextNode { return $applyNodeReplacement ( new ExtendedTextNode ( text
  ) ) ; } export function $isExtendedTextNode ( node : LexicalNode | null |
  undefined ) : node is ExtendedTextNode { return node instanceof
  ExtendedTextNode ; } function patchStyleConversion ( originalDOMConverter ? :
  ( node : HTMLElement ) =&gt; DOMConversion | null ) : ( node : HTMLElement )
  =&gt; DOMConversionOutput | null { return ( node ) =&gt; { const original =
  originalDOMConverter ?. ( node ) ; if ( ! original ) { return null ; } const
  originalOutput = original . conversion ( node ) ; if ( ! originalOutput ) {
  return originalOutput ; } const backgroundColor = node . style .
  backgroundColor ; const color = node . style . color ; const fontFamily = node
  . style . fontFamily ; const fontWeight = node . style . fontWeight ; const
  fontSize = node . style . fontSize ; const textDecoration = node . style .
  textDecoration ; return { ... originalOutput , forChild : ( lexicalNode ,
  parent ) =&gt; { const originalForChild = originalOutput ?. forChild ?? ( ( x
  ) =&gt; x ) ; const result = originalForChild ( lexicalNode , parent ) ; if (
  $isTextNode ( result ) ) { const style = [ backgroundColor ?
  <code>background-color: ${ backgroundColor }</code>
  : null , color ?
  <code>color: ${ color }</code>
  : null , fontFamily ?
  <code>font-family: ${ fontFamily }</code>
  : null , fontWeight ?
  <code>font-weight: ${ fontWeight }</code>
  : null , fontSize ?
  <code>font-size: ${ fontSize }</code>
  : null , textDecoration ?
  <code>text-decoration: ${ textDecoration }</code>
  : null , ] . filter ( ( value ) =&gt; value != null ) . join ( &#39;; &#39; )
  ; if ( style . length ) { return result . setStyle ( style ) ; } } return
  result ; } } ; } ; }
</p>
<h4 id="json">JSON</h4>
<h5 id="lexical-json">Lexical -&gt; JSON</h5>
<p>
  To generate a JSON snapshot from an EditorState , you can call the toJSON()
  method on the EditorState object. const editorState = editor . getEditorState
  ( ) ; const json = editorState . toJSON ( ) ;
</p>
<p>
  Alternatively, if you are trying to generate a stringified version of the
  EditorState , you can simply using JSON.stringify directly: const editorState
  = editor . getEditorState ( ) ; const jsonString = JSON . stringify (
  editorState ) ;
</p>
<h6 id="lexicalnode-exportjson">LexicalNode.exportJSON()</h6>
<p>
  You can control how a LexicalNode is represented as JSON by adding an
  exportJSON() method. It&#39;s important that you extend the serialization of
  the superclass by invoking super : e.g. { ...super.exportJSON(), /* your other
  properties */ } . export type SerializedLexicalNode = { type : string ;
  version : number ; } ; exportJSON ( ) : SerializedLexicalNode
</p>
<p>
  When transforming an editor state into JSON, we simply traverse the current
  editor state and call the exportJSON method for each Node in order to convert
  it to a SerializedLexicalNode object that represents the JSON object for the
  given node. The built-in nodes from Lexical already have a JSON representation
  defined, but you&#39;ll need to define ones for your own custom nodes.
  Here&#39;s an example of exportJSON for the HeadingNode : export type
  SerializedHeadingNode = Spread &lt; { tag : &#39;h1&#39; | &#39;h2&#39; |
  &#39;h3&#39; | &#39;h4&#39; | &#39;h5&#39; | &#39;h6&#39; ; } ,
  SerializedElementNode
</p>
<blockquote>
  <p>
    ; exportJSON ( ) : SerializedHeadingNode { return { ... super . exportJSON (
    ) , tag : this . getTag ( ) , } ; }
  </p>
</blockquote>
<h6 id="lexicalnode-importjson">LexicalNode.importJSON()</h6>
<p>
  You can control how a LexicalNode is deserialized back into a node from JSON
  by adding an importJSON() method. export type SerializedLexicalNode = { type :
  string ; version : number ; } ; importJSON ( jsonNode : SerializedLexicalNode
  ) : LexicalNode
</p>
<p>
  This method works in the opposite way to how exportJSON works. Lexical uses
  the type field on the JSON object to determine what Lexical node class it
  needs to map to, so keeping the type field consistent with the getType() of
  the LexicalNode is essential. You should use the updateFromJSON method in your
  importJSON to simplify the implementation and allow for future extension by
  the base classes. Here&#39;s an example of importJSON for the HeadingNode :
  static importJSON ( serializedNode : SerializedHeadingNode ) : HeadingNode {
  return $createHeadingNode ( ) . updateFromJSON ( serializedNode ) ; }
  updateFromJSON ( serializedNode : LexicalUpdateJSON &lt; SerializedHeadingNode
  &gt; , ) : this { return super . updateFromJSON ( serializedNode ) . setTag (
  serializedNode . tag ) ; }
</p>
<h6 id="lexicalnode-updatefromjson">LexicalNode.updateFromJSON()</h6>
<p>
  updateFromJSON is a method introduced in Lexical 0.23 to simplify the
  implementation of importJSON , so that a base class can expose the code that
  it is using to set all of the node&#39;s properties based on the JSON to any
  subclass. note The input type used in this method is not sound in the general
  case, but it is safe if subclasses only add optional properties to the JSON.
  Even though it is not sound, the usage in this library is safe as long as your
  importJSON method does not upcast the node before calling updateFromJSON .
  export type SerializedExtendedTextNode = Spread &lt; // UNSAFE. This property
  is not optional { newProperty : string } , SerializedTextNode
</p>
<blockquote>
  <p>
    ; export type SerializedExtendedTextNode = Spread &lt; // SAFE. This
    property is not optional { newProperty ? : string } , SerializedTextNode ;
  </p>
</blockquote>
<p>
  This is because it&#39;s possible to cast to a more general type, e.g. const
  serializedNode : SerializedTextNode = { /* ... */ } ; const newNode : TextNode
  = $createExtendedTextNode ( ) ; // This passes the type check, but would fail
  at runtime if the updateFromJSON method required newProperty newNode .
  updateFromJSON ( serializedNode ) ;
</p>
<h5 id="versioning-breaking-changes">Versioning &amp; Breaking Changes</h5>
<p>
  It&#39;s important to note that you should avoid making breaking changes to
  existing fields in your JSON object, especially if backwards compatibility is
  an important part of your editor. That&#39;s why we recommend using a version
  field to separate the different changes in your node as you add or change
  functionality of custom nodes. Here&#39;s the serialized type definition for
  Lexical&#39;s base TextNode class: import type { Spread } from
  &#39;lexical&#39; ; // Spread is a Typescript utility that allows us to spread
  the properties // over the base SerializedLexicalNode type. export type
  SerializedTextNode = Spread &lt; { detail : number ; format : number ; mode :
  TextModeType ; style : string ; text : string ; } , SerializedLexicalNode
</p>
<blockquote>
  <p>;</p>
</blockquote>
<p>
  If we wanted to make changes to the above TextNode , we should be sure to not
  remove or change an existing property, as this can cause data corruption.
  Instead, opt to add the functionality as a new optional property field
  instead. export type SerializedTextNode = Spread &lt; { detail : number ;
  format : number ; mode : TextModeType ; style : string ; text : string ; //
  Our new field we&#39;ve added newField ? : string , } , SerializedLexicalNode
</p>
<blockquote>
  <p>;</p>
</blockquote>
<h5 id="dangers-of-a-flat-version-property">
  Dangers of a flat version property
</h5>
<p>
  The updateFromJSON method should ignore type and version , to support
  subclassing and code re-use. Ideally, you should only evolve your types in a
  backwards compatible way (new fields are optional), and/or have a uniquely
  named property to store the version in your class. Generally speaking,
  it&#39;s best if nearly all properties are optional and the node provides
  defaults for each property. This allows you to write less boilerplate code and
  produce smaller JSON. The reason that version is no longer recommended is that
  it does not compose with subclasses. Consider this hierarchy: class TextNode {
  exportJSON ( ) { return { /* ... */ , version : 1 } ; } } class
  ExtendedTextNode extends TextNode { exportJSON ( ) { return { ... super .
  exportJSON ( ) } ; } }
</p>
<p>
  If TextNode is updated to version: 2 then this version and new serialization
  will propagate to ExtendedTextNode via the super.exportJSON() call, but this
  leaves nowhere to store a version for ExtendedTextNode or vice versa. If the
  ExtendedTextNode explicitly specified a version , then the version of the base
  class will be ignored even though the representation of the JSON from the base
  class may change: class TextNode { exportJSON ( ) { return { /* ... */ ,
  version : 2 } ; } } class ExtendedTextNode extends TextNode { exportJSON ( ) {
  // The super&#39;s layout has changed, but the version information is lost
  return { ... super . exportJSON ( ) , version : 1 } ; } }
</p>
<p>
  So then you have a situation where there are possibly two JSON layouts for
  ExtendedTextNode with the same version, because the base class version changed
  due to a package upgrade. If you do have incompatible representations,
  it&#39;s probably best to choose a new type. This is basically the only way
  that will force old configurations to fail, as importJSON implementations
  often don&#39;t do runtime validation and dangerously assume that the values
  are the correct type. There are other schemes that would allow for composable
  versions, such as nesting the superclass data, or choosing a different name
  for a version property in each subclass. In practice, explicit versioning is
  generally redundant if the serialization is properly parsed, so it is
  recommended that you use the simpler approach with a flat representation with
  mostly optional properties.
</p>
<ul>
  <li>HTMLLexical -&gt; HTML</li>
  <li>HTML -&gt; Lexical</li>
  <li>html Property for Import and Export Configuration</li>
  <li>Handling extended HTML styling</li>
  <li>JSONLexical -&gt; JSON</li>
  <li>Versioning &amp; Breaking Changes</li>
  <li>Dangers of a flat version property</li>
</ul>
<table></table>
