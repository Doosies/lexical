<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="updates">Updates</h3>
<p>
  Updates in Lexical are synchronous operations that mutate the editor state
  (except in nested update scenarios which should be deprecated). The
  reconciliation process (DOM updates) is batched for performance reasons. This
  batching of DOM updates means we can avoid unnecessary re-renders and optimize
  the rendering process.
</p>
<h4 id="update-tags">Update Tags</h4>
<p>
  Update tags are string identifiers that can be attached to an update to
  indicate its type or purpose. They can be used to control how updates are
  processed, merged, or handled by listeners. Multiple tags can be used in a
  single update. You can add tags in two ways:
</p>
<ol>
  <li>
    <p>
      Using the tag option in editor.update() : import { HISTORY_PUSH_TAG ,
      PASTE_TAG } from &#39;lexical&#39; ; editor . update ( ( ) =&gt; { // Your
      update code } , { tag : HISTORY_PUSH_TAG // Single tag } ) ; editor .
      update ( ( ) =&gt; { // Your update code } , { tag : [ HISTORY_PUSH_TAG ,
      PASTE_TAG ] // Multiple tags } ) ;
    </p>
  </li>
  <li>
    <p>
      Using the $addUpdateTag() function within an update: import {
      HISTORY_PUSH_TAG } from &#39;lexical&#39; ; editor . update ( ( ) =&gt; {
      $addUpdateTag ( HISTORY_PUSH_TAG ) ; // Your update code } ) ;
    </p>
  </li>
</ol>
<p>
  You can check if a tag is present using $hasUpdateTag() : import {
  HISTORIC_TAG } from &#39;lexical&#39; ; editor . update ( ( ) =&gt; {
  $addUpdateTag ( HISTORIC_TAG ) ; console . log ( $hasUpdateTag ( HISTORIC_TAG
  ) ) ; // true } ) ;
</p>
<div class="g3mark-callout g3mark-callout-note">
  <span class="g3mark-callout__icon" aria-hidden="true"></span>
  <p>
    <span class="g3mark-callout__keyword">Note:</span>
    While update tags can be checked within the same update using
    $hasUpdateTag() , they are typically accessed in update and mutation
    listeners through the tags and updateTags properties in their respective
    payloads. Here&#39;s the more common usage pattern: import { HISTORIC_TAG }
    from &#39;lexical&#39; ; editor . registerUpdateListener ( ( { tags } )
    =&gt; { if ( tags . has ( HISTORIC_TAG ) ) { // Handle updates with historic
    tag } } ) ; editor . registerMutationListener ( MyNode , ( mutations ) =&gt;
    { // updateTags contains tags from the current update if ( mutations .
    updateTags . has ( HISTORIC_TAG ) ) { // Handle mutations with historic tag
    } } ) ;
  </p>
</div>
<h5 id="common-update-tags">Common Update Tags</h5>
<p>
  Lexical provides several built-in update tags that are exported as constants:
</p>
<ul>
  <li>
    HISTORIC_TAG : Indicates that the update is related to history operations
    (undo/redo)
  </li>
  <li>HISTORY_PUSH_TAG : Forces a new history entry to be created</li>
  <li>
    HISTORY_MERGE_TAG : Merges the current update with the previous history
    entry
  </li>
  <li>PASTE_TAG : Indicates that the update is related to a paste operation</li>
  <li>
    COLLABORATION_TAG : Indicates that the update is related to collaborative
    editing
  </li>
  <li>
    SKIP_COLLAB_TAG : Indicates that the update should skip collaborative sync
  </li>
  <li>
    SKIP_SCROLL_INTO_VIEW_TAG : Prevents scrolling the selection into view
  </li>
  <li>
    SKIP_DOM_SELECTION_TAG : Prevents updating the DOM selection (useful for
    updates that shouldn&#39;t affect focus)
  </li>
</ul>
<h5 id="tag-validation">Tag Validation</h5>
<p>
  To prevent typos and ensure type safety when using update tags, Lexical
  exports constants for all built-in tags. It&#39;s recommended to always use
  these constants instead of string literals: import { HISTORIC_TAG ,
  HISTORY_PUSH_TAG , COLLABORATION_TAG , } from &#39;lexical&#39; ; editor .
  update ( ( ) =&gt; { // Using constants ensures type safety and prevents typos
  $addUpdateTag ( HISTORIC_TAG ) ; // These constants can be used in update
  options editor . update ( ( ) =&gt; { // Your update code } , { tag :
  HISTORY_PUSH_TAG } ) ; // And in listener checks editor .
  registerUpdateListener ( ( { tags } ) =&gt; { if ( tags . has (
  COLLABORATION_TAG ) ) { // Handle collaborative updates } } ) ; } ) ;
</p>
<h5 id="custom-tags">Custom Tags</h5>
<p>
  While Lexical provides common tags as constants, you can also define your own
  constants for custom tags to maintain consistency and type safety:
</p>
<ul>
  <li>
    // Define your custom tags as constants const MY_FEATURE_TAG =
    &#39;my-custom-feature&#39; ; const MY_UPDATE_TAG =
    &#39;my-custom-update&#39; ; editor . update ( ( ) =&gt; { $addUpdateTag (
    MY_FEATURE_TAG ) ; } , { tag : MY_UPDATE_TAG } ) ; // Listen for updates
    with specific tags editor . registerUpdateListener ( ( { tags } ) =&gt; { if
    ( tags . has ( MY_FEATURE_TAG ) ) { // Handle updates from your custom
    feature } } ) ; Update TagsCommon Update Tags
  </li>
  <li>Tag Validation</li>
  <li>Custom Tags</li>
</ul>
