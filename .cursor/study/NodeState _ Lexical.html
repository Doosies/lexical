<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="nodestate">NodeState</h3>
<p>
  The NodeState API introduced in v0.26.0 allows arbitrary state to be added
  ad-hoc to any node in a way that participates with reconciliation, history,
  and JSON serialization.
</p>
<h4 id="use-case">Use Case</h4>
<p>
  NodeState allows your application to define keys that can be stored on any
  node with automatic JSON support, you can even add state to the root node to
  store document-level metadata. tip You can even add node state to the RootNode
  to store document-level metadata, which wasn&#39;t possible at all before!
  With a combination of NodeState and other APIs such as Listeners or Transforms
  you can likely shape the editor to meet your needs without having to do much
  Node Customization. Even when you are subclassing nodes, using NodeState
  instead of additional properties to store the node&#39;s data can be more
  efficient and will save you from writing a lot of boilerplate in the
  constructor, updateFromJSON, and exportJSON.
</p>
<h4 id="stability">Stability</h4>
<p>
  ðŸ§ª This API is experimental, and may evolve without a long deprecation period.
  See also Capabilities for notes on what it can and can not do out of the box
  today.
</p>
<h4 id="usage">Usage</h4>
<h5 id="createstate">createState</h5>
<p>
  createState creates a StateConfig which defines the key and configuration for
  your NodeState value. The key must be locally unique, two distinct StateConfig
  must not have the same string key if they are to be used on the same node.
  Typical usage will look something like this: const questionState = createState
  ( &#39;question&#39; , { parse : ( v ) =&gt; ( typeof v === &#39;string&#39; ?
  v : &#39;&#39; ) , } ) ;
</p>
<p>The required parse function serves two purposes:</p>
<ul>
  <li>
    It provides a type-safe and runtime-safe way to parse values that were
    serialized to JSON
  </li>
  <li>
    When called with undefined (or any invalid value) it should return some
    default value (which may be undefined or null or any other value you choose)
    In this case, the question must be a string, and the default is an empty
    string. See the createState API documentation for more details, there are
    other optional settings that you may want to define particularly if the
    value is not a primitive value such as boolean, string, number, null, or
    undefined. tip We recommend building a library of small reusable parse
    functions for the data types that you use, or a library that can be used to
    generate them such as zod, ArkType, Effect, Valibot, etc. especially when
    working with non-primitive data types.
  </li>
</ul>
<h5 id="getstate">$getState</h5>
<p>
  $getState gets the NodeState value from the given node, or the default if that
  key was never set on the node. const question = $getState ( pollNode ,
  questionState ) ;
</p>
<p>
  See also $getStateChange if you need an efficient way to determine if the
  state has changed on two versions of the same node (typically used in
  updateDOM, but may be useful in an update listener or mutation listener).
</p>
<h5 id="setstate">$setState</h5>
<p>
  $setState sets the NodeState value on the given node. const question =
  $setState ( pollNode , questionState , &#39;Are you planning to use
  NodeState?&#39; , ) ; tip The last argument is a ValueOrUpdater, just like
  with React&#39;s useState setters. If you use an updater function and the
  value does not change, the node and its NodeState
  <em>won&#39;t</em>
  be marked dirty.
</p>
<h4 id="serialization">Serialization</h4>
<p>
  The NodeState for a node, if any values are set to non-default values, is
  serialized to a record under a single NODE_STATE_KEY which is equal to
  &#39;$&#39; . In the future, it is expected that nodes will be able to declare
  required state and lift those values to the top-level of their serialized
  nodes (see #7260). { &#34;type&#34;: &#34;poll&#34;, &#34;$&#34;: {
  &#34;question&#34;: &#34;Are you planning to use NodeState?&#34;, } } tip By
  default, it is assumed that your parsed values are JSON serializable, but for
  advanced use cases you may use values such as Date, Map, or Set that need to
  be transformed before JSON serialization. See the StateValueConfig API
  documentation.
</p>
<h4 id="efficiency">Efficiency</h4>
<p>
  NodeState uses a copy-on-write scheme to manage each node&#39;s state. If none
  of the state has changed, then the NodeState instance will be shared across
  multiple versions of that node. info In a given reconciliation cycle, the
  first time a Lexical node is marked dirty via getWritable will create a new
  instance of that node. All properties of the previous version are set on the
  new instance. NodeState is stored as a single property, and no copying of the
  internal state is done until the NodeState itself is marked writable. When
  serializing to JSON, each key will only be stored if the value is not equal to
  the default value. This can save quite a lot of space and bandwidth. Parsing
  and serialization is only done at network boundaries, when integrating with
  JSON or Yjs. When a value changes from an external source, it is only parsed
  once the first time it is read. Values that do not come from external sources
  are not parsed, and values that are not used are never parsed.
</p>
<h4 id="capabilities">Capabilities</h4>
<p>Current:</p>
<ul>
  <li>Allows you to define and add state to any node</li>
  <li>
    Serializes that state automatically in the node&#39;s JSON, supporting
    versioning and copy+paste
  </li>
  <li>
    Works with the reconciler, TextNodes with differing state will not be
    implicitly merged
  </li>
  <li>
    @lexical/yjs support, NodeState will be automatically synchronized like any
    other property
  </li>
  <li>
    NodeState values that are not used will simply pass-through, making it a bit
    easier for situations where multiple configurations are used on the same
    data (e.g. older and newer versions of your editor, a different set of
    plugins based on context, etc.).
  </li>
  <li>
    Pre-registration system for nodes to declare expected state and serialize
    them as top-level properties ( flat ) with $config (see #7260). Future:
  </li>
  <li>
    Does not yet integrate directly with importDOM, createDOM or exportDOM (see
    #7259)
  </li>
  <li>
    Does not yet support direct integration with Yjs, e.g. you can not store a
    Y.Map as a NodeState value (see #7293)
  </li>
  <li>
    There isn&#39;t yet an easy way to listen for updates to NodeState without
    registering listeners for every class (see #7321)
  </li>
  <li>
    Similarly, there isn&#39;t the equivalent of a node transform for NodeState.
    Transforms must be registered on individual node classes.
  </li>
</ul>
<h4 id="node-state-style-example">Node State Style Example</h4>
<p>
  This example demonstrates an advanced use case of storing a style object on
  TextNode using NodeState.
</p>
<ul>
  <li>Use Case</li>
  <li>Stability</li>
  <li>UsagecreateState</li>
  <li>$getState</li>
  <li>
    $setState Serialization Efficiency Capabilities Node State Style Example
  </li>
</ul>
