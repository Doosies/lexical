<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="creating-a-react-plugin">Creating a React Plugin</h3>
<p>
  In addition to using the Lexical React plugins offered by the core library,
  you can make your own plugins to extend or alter Lexical&#39;s functionality
  to suit your own use cases. Lexical&#39;s React plugin interface is simple -
  just create a React component and add it as a child of your LexicalComposer
  component: &lt; LexicalComposer &gt; &lt; MyLexicalPlugin &gt; &lt;/
  LexicalComposer &gt;
</p>
<p>
  If the Plugin introduces new nodes, they have to be registered in
  initialConfig.nodes : const initialConfig = { namespace : &#39;MyEditor&#39; ,
  nodes : [ MyLexicalNode ] , } ; &lt; LexicalComposer initialConfig = {
  initialConfig } &gt; &lt; MyLexicalPlugin &gt; &lt;/ LexicalComposer &gt;
</p>
<p>
  LexicalComposer provides access to the underlying LexicalEditor instance via
  React Context: //MyLexicalPlugin.js export function MyLexicalPlugin ( props )
  { const [ editor ] = useLexicalComposerContext ( ) ; ... }
</p>
<p>
  With access to the Editor, your plugin can extend Lexical via Commands,
  Transforms, or other APIs. For example, the TwitterPlugin embeds a tweet into
  the editor, fetching the data asynchronously from Twitter based on the
  provided Tweet ID: export const INSERT_TWEET_COMMAND : LexicalCommand &lt;
  string &gt; = createCommand(); export default function TwitterPlugin():
  JSX.Element | null { const [ editor ] = useLexicalComposerContext ( ) ;
  useEffect ( ( ) =&gt; { if ( ! editor . hasNodes ( [ TweetNode ] ) ) { throw
  new Error ( &#39;TwitterPlugin: TweetNode not registered on editor
  (initialConfig.nodes)&#39; ) ; } return editor . registerCommand &lt; string
  &gt; ( INSERT_TWEET_COMMAND, (payload) =&gt; { const tweetNode =
  $createTweetNode ( payload ) ; $insertNodeToNearestRoot ( tweetNode ) ; return
  true ; } , COMMAND_PRIORITY_EDITOR, ); }, [editor]); return null; }
</p>
<p>
  TwitterPlugin is just a React component that accesses the Lexical editor via
  React Context (useLexicalComposerContext). Using the LexicalEditor instance,
  this plugin does two things:
</p>
<ol>
  <li>
    Verifies that there is a TweetNode registered on the editor (if you forget
    to register the node, you can&#39;t do #2)
  </li>
  <li>
    registers a &#34;command&#34;, passing a callback that will run when that
    command is dispatched. The command callback creates and inserts a TweetNode
    in the editor. You can see how TwitterPlugin is used in the playground.
    It&#39;s added as a child of a LexicalComposer component, which does the job
    of providing the Context necessary for access to the editor instance. To
    actually trigger this command callback and insert a TweetNode, we have a
    button that &#34;dispatches&#34; the Tweet command we registered in the
    plugin. While the TwitterPlugin registers a command that inserts a custom
    node, this is only one example of what can be done with a plugin. To get a
    better idea of what&#39;s possible, take a look at the plugins defined in
    the playground.
  </li>
</ol>
