<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="node-traversals-with-nodecaret">Node Traversals with NodeCaret</h3>
<p>
  NodeCaret offers a unified and efficient way for traversing the document tree,
  making it much easier to correctly implement traversals and avoid edge cases
  around empty nodes and collapsed selections. These new low-level functions
  were all designed to work together as a fully featured relatively lightweight
  API to use in the core to allow us to gradually address some edge cases and
  then simplify and shrink the code. We expect higher-level utilities to be
  developed and shipped in @lexical/utils or another module at a later date. The
  current overhead should be less than 3kB in a production environment. The
  NodeCaret API was introduced in lexical v0.25.0.
</p>
<h4 id="concepts">Concepts</h4>
<p>
  The core concept with NodeCaret is that you can represent any specific point
  in the document by using an origin node, a direction that points towards an
  adjacent node ( next or previous ), and a type to specify whether the arrow
  points towards a sibling ( sibling ) or towards a child ( child ). All of
  these types have a D type parameter that must be a CaretDirection , so you can
  not accidentally mix up next and previous carets. Many of them also have a T
  type parameter that encodes the type of the origin node. tip The methods of a
  caret are designed to operate on nodes attached to the origin in the
  designated direction, not the origin itself. For example, this code is a no-op
  because it will attach a node to the origin , and then remove the node that
  was just attached. // The origin is unaffected (other than being marked dirty)
  caret . insert ( $createTextNode ( &#39;no-op&#39; ) ) . remove ( ) ; warning
  Carets are immutable, and designed for low-level usage. There is no attempt
  for carets to automatically update based on changes to the document (this is a
  common source of bugs when working with RangeSelection ). Functions and
  methods that work with carets and are expected to change the structure of the
  document will always return a possibly new caret. The origin of a caret is the
  exact version of the object that it was constructed with, all accessor methods
  on that origin will generally call origin.getLatest() so the operations will
  see the latest version.
</p>
<h5 id="nodecaret">NodeCaret</h5>
<p>NodeCaret is any SiblingCaret or any ChildCaret</p>
<ul>
  <li>
    Typically constructed with $getChildCaretOrSelf($getSiblingCaret(origin,
    direction)) which returns a ChildCaret when the origin is an ElementNode tip
    This type does not include TextPointCaret or TextPointCaretSlice , so you
    will not have to consider those edge cases when you see this more specific
    type.
  </li>
</ul>
<h5 id="siblingcaret">SiblingCaret</h5>
<p>SiblingCaret is a caret that points towards a sibling of the origin</p>
<ul>
  <li>
    Constructed with $getSiblingCaret(origin: LexicalNode, direction:
    CaretDirection)
  </li>
  <li>The next direction points towards the right</li>
  <li>
    The previous direction points towards the left → direction: &#39;next&#39; ←
    direction: &#39;previous&#39; getParentAtCaret() origin.getParent()
    origin.getParent() getNodeAtCaret() origin.getNextSibling()
    origin.getPreviousSibling() insert(node) origin.insertAfter(node)
    origin.insertBefore(node)
  </li>
</ul>
<h5 id="childcaret">ChildCaret</h5>
<p>
  ChildCaret is a caret that points towards the first or last child of the
  origin
</p>
<ul>
  <li>
    Constructed with $getChildCaret(origin: ElementNode, direction:
    CaretDirection)
  </li>
  <li>The next direction points towards the first child</li>
  <li>
    The previous direction points towards the last child ↘ direction:
    &#39;next&#39; ↙ direction: &#39;previous&#39; getParentAtCaret() origin
    origin getNodeAtCaret() origin.getFirstChild() origin.getLastChild()
    insert(node) origin.splice(0, 0, node) origin.append(node)
  </li>
</ul>
<h5 id="pointcaret">PointCaret</h5>
<p>
  PointCaret is any TextPointCaret , SiblingCaret or ChildCaret . This type can
  be used to represent any point in the document that PointType can represent.
</p>
<h5 id="textpointcaret">TextPointCaret</h5>
<p>
  TextPointCaret is basically a SiblingCaret with a TextNode origin and an
  offset property
</p>
<ul>
  <li>Constructed with $getTextPointCaret(origin, direction, offset)</li>
  <li>The offset property is an absolute index into the string</li>
  <li>The next direction implies all text content after offset</li>
  <li>The previous direction implies all text content before offset</li>
  <li>
    All methods that are also present on SiblingCaret behave in the same way
  </li>
</ul>
<h5 id="textpointcaretslice">TextPointCaretSlice</h5>
<p>
  TextPointCaretSlice is a wrapper for TextPointCaret that provides a signed
  distance .
</p>
<ul>
  <li>Constructed with $getTextPointCaretSlice(caret, distance)</li>
  <li>
    There are convenience methods like removeTextSlice() and getTextContent() ,
    so it&#39;s not generally necessary to know the implementation details here
  </li>
  <li>
    Math.min(caret.offset, caret.offset + distance) refers to the start offset
    of the slice
  </li>
  <li>
    Math.max(caret.offset, caret.offset + distance) refers to the end offset of
    the slice
  </li>
  <li>
    The direction of the caret is generally ignored when working with a
    TextPointCaretSlice , the slice is in absolute string coordinates info The
    property name distance was chosen because length and size are commonly used
    on other data structures in JavaScript and Lexical, and they are
    overwhelmingly non-negative. While most uses of distance are also
    non-negative, in some contexts such as computer graphics it is not uncommon
    to use Signed distance functions where the distance metric is signed. In SDF
    terms, the subset of the space is [offset, ∞) . Any coordinate less than the
    offset boundary is a negative distance; otherwise the distance is
    non-negative.
  </li>
</ul>
<h5 id="caretrange">CaretRange</h5>
<p>
  CaretRange contains a pair of PointCaret that are in the same direction. It is
  equivalent in purpose to a RangeSelection , and is what you would generally
  use for depth first traversals.
</p>
<ul>
  <li>
    Constructed with $getCaretRange(anchor, focus) ,
    $caretRangeFromSelection(selection) , or $extendCaretToRange(anchor)
  </li>
  <li>
    The anchor is the start of the range, generally where the selection
    originated, and it is &#34;anchored&#34; in place because when a selection
    grows or shrinks only the focus will be moved
  </li>
  <li>
    The focus is the end of the range, where the blinking cursor is, it&#39;s
    the current focus of the user
  </li>
  <li>
    Anchor and focus must point in the same direction. The anchor points towards
    the first node
    <em>in the range</em>
    and the focus points towards the first node
    <em>not in the range</em>
  </li>
  <li>
    The getTextSlices() method is essential to handle the literal edge cases
    where the anchor and/or focus are a TextPointCaret . These edges are
    <em>not</em>
    included in the default caret iteration of the CaretRange . warning If you
    are iterating a CaretRange you must consider the getTextSlices() separately,
    they are not included in the iteration. This is so you don&#39;t have to
    consider TextPointCaretSlice at every step. They are literal edge cases that
    can only be at the start and/or end and typically have special treatment
    (splitting instead of removing, for example).
  </li>
</ul>
<h4 id="traversal-strategies">Traversal Strategies</h4>
<h5 id="adjacent-caret-traversals">Adjacent Caret Traversals</h5>
<p>
  The lowest level building block for traversals with NodeCaret is the adjacent
  caret traversal, which is supported directly by methods of NodeCaret.
  getAdjacentCaret() - Gets a SiblingCaret for the node attached to origin in
  direction. If there is no attached node, it will return null
  getParentCaret(rootMode) - Gets a SiblingCaret for the parent node of origin
  in the same direction. If there is no parent node, or the parent is a root
  according to rootMode , then it will return null . rootMode may be
  &#39;root&#39; to only return null for RootNode or &#39;shadowRoot&#39; to
  return null for RootNode or any ElementNode parent where isShadowRoot()
  returns true getChildCaret() - Gets a ChildCaret for this origin, or null if
  the origin is not an ElementNode . Will return this if the caret is already a
  ChildCaret For example, iterating all siblings: // Note that NodeCaret
</p>
<h5 id="examples">Examples</h5>
<p>
  Given the following document tree, here are some examples of using the
  adjacent node traversal: Root Paragraph A
</p>
<ul>
  <li>Text A1 Link A2</li>
  <li>Text A3 Text A4 Paragraph B</li>
  <li>
    Text B1 Paragraph C // The root does not have sibling nodes const carets = [
    ... $getSiblingCaret ( $getRoot ( ) , &#39;next&#39; ) ] ; expect ( carets )
    . toEqual ( [ ] ) ; // The adjacent node to a ChildNode is its first or last
    child // and is always a SiblingNode. It does not traverse deeper. const
    carets = [ ... $getChildCaret ( $getRoot ( ) , &#39;next&#39; ) ] ; // next
    starts at the first child expect ( carets ) . toEqual ( [ $getSiblingCaret (
    paragraphA , &#39;next&#39; ) , $getSiblingCaret ( paragraphB ,
    &#39;next&#39; ) , $getSiblingCaret ( paragraphC , &#39;next&#39; ) , ] ) ;
    // previous starts at the last child const prevCarets = [ ... $getChildCaret
    ( $getRoot ( ) , &#39;previous&#39; ) ] ; expect ( prevCarets ) . toEqual (
    [ $getSiblingCaret ( paragraphC , &#39;previous&#39; ) , $getSiblingCaret (
    paragraphB , &#39;previous&#39; ) , $getSiblingCaret ( paragraphA ,
    &#39;previous&#39; ) , ] ) ; // The iteration starts at the node where the
    head of the &#34;arrow&#34; // is pointing, which is away from the origin
    (the tail of the &#34;arrow&#34;). const carets = [ ... $getSiblingCaret (
    paragraphB , &#39;next&#39; ) ] ; expect ( carets ) . toEqual ( [
    $getSiblingCaret ( paragraphC , &#39;next&#39; ) , ] ) ; const prevCarets =
    [ ... $getSiblingCaret ( paragraphB , &#39;previous&#39; ) ] ; expect (
    prevCarets ) . toEqual ( [ $getSiblingCaret ( paragraphA ,
    &#39;previous&#39; ) , ] ) ;
  </li>
</ul>
<h5 id="depth-first-caret-traversals">Depth First Caret Traversals</h5>
<p>
  The strategy to do a depth-first caret traversal is to use an adjacent caret
  traversal and immediately use a ChildCaret any time that an ElementNode origin
  is encountered. This strategy yields all possible carets, but each ElementNode
  in the traversal may be yielded once or twice (a ChildCaret on enter, and a
  SiblingCaret on leave). Allowing you to see whether an ElementNode is
  partially included in the range or not is one of the reasons that this
  abstraction exists. function * $iterCaretsDepthFirst &lt; D extends
  CaretDirection &gt; ( startCaret : NodeCaret &lt; D &gt; ) : Iterable &lt;
  NodeCaret &lt; D &gt;&gt; { function step ( prevCaret : NodeCaret &lt; D &gt;
  ) : null | NodeCaret &lt; D &gt; { // Get the adjacent SiblingCaret const
  nextCaret = prevCaret . getAdjacentCaret ( ) ; return ( // If there is a
  sibling, try and get a ChildCaret from it ( nextCaret &amp;&amp; nextCaret .
  getChildCaret ( ) ) || // Return the sibling if there is one nextCaret || //
  Return a SiblingCaret of the parent, if there is one prevCaret .
  getParentCaret ( &#39;root&#39; ) ) ; } // You may add an additional check
  here, usually some specific // caret to terminate the iteration with (such as
  the parent caret // of startCaret): // //
  <code>caret !== null || caret.is(endCaret)</code>
  // for ( let caret = step ( startCaret ) ; caret !== null ; caret = step (
  caret ) ) { yield caret ; } }
</p>
<p>
  Normally this type of iteration would be done from a CaretRange , where you
  would specify a precise end caret (focus). function $iterCaretsDepthFirst &lt;
  D extends CaretDirection &gt; ( startCaret : NodeCaret &lt; D &gt; , endCaret
  ? : NodeCaret &lt; D &gt; , ) : Iterable &lt; NodeCaret &lt; D &gt;&gt; {
  return $getCaretRange ( startCaret , // Use the root as the default end caret,
  but you might choose // to use startCaret.getParentCaret(&#39;root&#39;) for
  example endCaret || $getSiblingCaret ( $getRoot ( ) , startCaret . direction )
  ) ; }
</p>
<p>
  To get all nodes that are entirely selected between two carets: function *
  $iterNodesDepthFirst &lt; D extends CaretDirection &gt; ( startCaret :
  NodeCaret &lt; D &gt; , endCaret : NodeCaret &lt; D &gt; = $getChildCaret (
  $getRoot ( ) , startCaret . direction ) , ) : Iterable &lt; LexicalNode &gt; {
  const seen = new Set &lt; NodeKey &gt; ( ) ; for ( const caret of
  $getCaretRange ( startCaret , endCaret ) ) { const { origin } = caret ; if (
  $isChildCaret ( caret ) ) { seen . add ( origin . getKey ( ) ) ; } else if ( !
  $isElementNode ( origin ) || seen . has ( origin . getKey ( ) ) ) { // If the
  origin is an element and we have not seen it as a ChildCaret // then it was
  not entirely in the CaretRange yield origin ; } } }
</p>
<h5 id="examples-2">Examples</h5>
<p>
  Given the following document tree, here are some examples of using the
  depth-first node traversal (with a CaretRange ): Root Paragraph A
</p>
<ul>
  <li>Text A1 Link A2</li>
  <li>Text A3 Text A4 Paragraph B</li>
  <li>
    Text B1 Paragraph C // A full traversal of the document from root const
    carets = [ ... $getCaretRange ( // Start with the arrow pointing towards the
    first child of root $getChildCaret ( $getRoot ( ) , &#39;next&#39; ) , //
    End when the arrow points away from root $getSiblingCaret ( $getRoot ( ) ,
    &#39;next&#39; ) , ) ] ; expect ( carets ) . toEqual ( [ $getChildCaret (
    paragraphA , &#39;next&#39; ) , // enter Paragraph A $getSiblingCaret (
    textA1 , &#39;next&#39; ) , $getChildCaret ( linkA2 , &#39;next&#39; ) , //
    enter Link A2 $getSiblingCaret ( textA3 , &#39;next&#39; ) ,
    $getSiblingCaret ( linkA2 , &#39;next&#39; ) , // leave Link A2
    $getSiblingCaret ( textA4 , &#39;next&#39; ) , $getSiblingCaret ( paragraphA
    , &#39;next&#39; ) , // leave Paragraph A $getChildCaret ( paragraphB ,
    &#39;next&#39; ) , // enter Paragraph B $getSiblingCaret ( textB1 ,
    &#39;next&#39; ) , $getSiblingCaret ( paragraphB , &#39;next&#39; ) , //
    leave Paragraph B $getChildCaret ( paragraphC , &#39;next&#39; ) , // enter
    Paragraph C $getSiblingCaret ( paragraphC , &#39;next&#39; ) , // leave
    Paragraph C ] ) ;
  </li>
</ul>
<h4 id="future-direction">Future Direction</h4>
<p>
  It&#39;s expected that higher-level abstractions will be built on top of this
  outside of the core, either in @lexical/utils or a separate companion package.
  This is just designed to be the lowest-level layer with a consistent and
  type-safe interface. That sort of abstraction will probably look a little bit
  like cheerio or jQuery, but for working with Lexical documents. It is not
  expected that more abstractions will be added to the core. In order to reduce
  code size and eliminate bugs, more of the core will be refactored to use
  NodeCaret internally. Once this happens, it&#39;s possible that the internal
  structure of PointType and/or RangeSelection may change to accommodate
  NodeCaret, as it is more resilient to document changes (only changes that
  directly affect the origin node will &#34;break&#34; the point). A simple
  version of this would be to create a caret any time that the point changes,
  and use that caret as a fallback if the selection would otherwise be lost. It
  may be the case that NodeCaret will become the lowest level API, working
  directly with private LexicalNode/ElementNode internals. When/if that happens,
  the methods on LexicalNode will remain for backwards compatibility, but
  overriding them will not be supported. It isn&#39;t particularly safe to
  override them as-is anyway, and these overrides are frequently the root cause
  of bugs (e.g. parents that remove themselves after an operation on a child,
  causing the point to be lost unless the caller was sophisticated enough to
  store the array of parents).
</p>
<h4 id="history">History</h4>
<p>
  Before NodeCaret, Lexical&#39;s core API offered a relatively low-level
  DOM-like interface for working with nodes and traversing them. It has
  accumulated many functions over time for performing various kinds of
  traversals around the tree (finding ancestors, children, depth, siblings,
  etc.), but most of them are not implemented in a way that makes them easy to
  combine efficiently, and many of them have edge cases that are difficult to
  avoid and can&#39;t really be addressed without breaking compatibility. Many
  of these functions also have a lot of edge cases, particularly around assuming
  the reference nodes are inclusive. Many are also left-to-right biased,
  don&#39;t offer an iterative version that can be aborted early or consumed on
  the fly, etc. Refactoring many of these to use something like PointType would
  almost be sufficient for many of these use cases, but the representation of
  that type is inefficient and error-prone as any mutation to the tree requires
  that each point be manually recomputed. PointType is also directionless,
  forcing a specific left-to-right bias into most APIs. RangeSelection can be
  used in many cases because a direction can be inferred from any two different
  points, but that collapses with a single point. It&#39;s also impractical to
  use RangeSelection concurrently with mutations due to the problems with
  PointType . NodeCaret was born out of frustration with these APIs and a desire
  to unify it all in a coherent way to simplify and reduce errors in the core.
</p>
<h4 id="terminology">Terminology</h4>
<h5 id="caret">Caret</h5>
<p>
  The term Caret was chosen because it is concise and specific term specific to
  a point in a text document. Lexical is &#34;an extensible text editor
  framework&#34; so it makes sense that navigation in the document would use
  terms relevant to text. Most other terms such as Cursor or Point already have
  meanings in Lexical and/or are less specific. See also:
</p>
<ul>
  <li>Caret</li>
  <li>Caret navigation</li>
</ul>
<h5 id="origin">Origin</h5>
<p>
  The origin is the reference node for a NodeCaret. Absolute coordinates are
  determined by combining this origin node and an &#34;arrow&#34; that points
  towards to where the adjacent node is (or could be). The &#34;arrow&#34; is
  determined by the direction and type of the caret. In a way this
  &#34;arrow&#34; is considered to be something like a unit vector to indicate
  the direction, and adding it to an origin allows you to specify an absolute
  location relative to that origin. Unlike the other coordinate systems
  available in Lexical, it does not need recomputing whenever siblings or a
  parent changes, so long as the origin node is still attached. See also:
</p>
<ul>
  <li>Origin</li>
  <li>Unit Vector</li>
</ul>
<h5 id="childcaret-siblingcaret">ChildCaret / SiblingCaret</h5>
<p>
  These were chosen because they match the existing methods on ElementNode and
  LexicalNode ( getFirstChild , getNextSibling , etc.)
</p>
<h5 id="direction">Direction</h5>
<p>
  &#39;next&#39; and &#39;previous&#39; were chosen for direction mostly to
  match the existing methods such as getNextSibling() that exist in DOM and in
  Lexical. Using other words such as &#39;left&#39; and &#39;right&#39; would be
  ambiguous since text direction can be bidirectional and already uses the terms
  left-to-right and right-to-left.
</p>
<h5 id="distance">Distance</h5>
<p>
  The property name distance was chosen for TextPointCaretSlice because length
  and size are commonly used on other data structures in JavaScript and Lexical,
  and they are overwhelmingly non-negative. While most uses of distance are also
  non-negative, in some contexts such as computer graphics it is not uncommon to
  use Signed distance functions where the distance metric is signed. In SDF
  terms, the subset of the space is [offset, ∞) . Any coordinate less than the
  offset boundary is a negative distance; otherwise the distance is
  non-negative.
</p>
<ul>
  <li>ConceptsNodeCaret</li>
  <li>SiblingCaret</li>
  <li>ChildCaret</li>
  <li>PointCaret</li>
  <li>TextPointCaret</li>
  <li>TextPointCaretSlice</li>
  <li>CaretRange</li>
  <li>Traversal StrategiesAdjacent Caret Traversals</li>
  <li>Examples</li>
  <li>Depth First Caret Traversals</li>
  <li>Examples Future Direction History</li>
  <li>TerminologyCaret</li>
  <li>Origin</li>
  <li>ChildCaret / SiblingCaret</li>
  <li>Direction</li>
  <li>Distance</li>
</ul>
