<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="working-with-dom-events">Working with DOM Events</h3>
<p>
  Sometimes, when working with Lexical, it might be necessary or useful for you
  to attach a DOM Event Listener to the underlying DOM nodes that Lexical
  controls. For instance, you might want to show a popover when a user mouses
  over a specific node or open a modal when they click on a node. Either of
  these use cases (and many others) can be accomplished via native DOM Event
  Listeners. There are 3 main ways that you can listen for DOM Events on nodes
  controlled by Lexical:
</p>
<h4 id="1-event-delegation">1. Event Delegation</h4>
<p>
  One way to handle events inside the editor is to set a listener on the editor
  root element (the contentEditable Lexical attaches to). You can do this using
  a Root Listener. function myListener ( event ) { // You may want to filter on
  the event target here // to only include clicks on certain types of DOM Nodes.
  alert ( &#39;Nice!&#39; ) ; } const removeRootListener = editor .
  registerRootListener ( ( rootElement , prevRootElement ) =&gt; { // add the
  listener to the current root element rootElement . addEventListener (
  &#39;click&#39; , myListener ) ; // remove the listener from the old root
  element - make sure the ref to myListener // is stable so the removal works
  and you avoid a memory leak. prevRootElement . removeEventListener (
  &#39;click&#39; , myListener ) ; } ) ; // teardown the listener - return this
  from your useEffect callback if you&#39;re using React. removeRootListener ( )
  ;
</p>
<p>
  This can be a simple, efficient way to handle some use cases, since it&#39;s
  not necessary to attach a listener to each DOM node individually.
</p>
<h4 id="2-directly-attach-handlers">2. Directly Attach Handlers</h4>
<p>
  In some cases, it may be better to attach an event handler directly to the
  underlying DOM node of each specific node. With this approach, you generally
  don&#39;t need to filter the event target in the handler, which can make it a
  bit simpler. It will also guarantee that your handler isn&#39;t running for
  events that you don&#39;t care about. This approach is implemented via a
  Mutation Listener. const registeredElements : WeakSet &lt; HTMLElement &gt; =
  new WeakSet ( ) ; const removeMutationListener = editor .
  registerMutationListener ( nodeType , ( mutations ) =&gt; { editor .
  getEditorState ( ) . read ( ( ) =&gt; { for ( const [ key , mutation ] of
  mutations ) { const element : null | HTMLElement = editor . getElementByKey (
  key ) ; if ( // Updated might be a move, so that might mean a new DOM element
  // is created. In this case, we need to add an event listener too. ( mutation
  === &#39;created&#39; || mutation === &#39;updated&#39; ) &amp;&amp; element
  !== null &amp;&amp; ! registeredElements . has ( element ) ) {
  registeredElements . add ( element ) ; element . addEventListener (
  &#39;click&#39; , ( event : Event ) =&gt; { alert ( &#39;Nice!&#39; ) ; } ) ;
  } } } ) ; } ) ; // teardown the listener - return this from your useEffect
  callback if you&#39;re using React. removeMutationListener ( ) ;
</p>
<p>
  Notice that here we don&#39;t worry about cleaning up, as Lexical will
  dereference the underlying DOM nodes and allow the JavaScript runtime garbage
  collector to clean up their listeners.
</p>
<h4 id="3-use-nodeeventplugin">3. Use NodeEventPlugin</h4>
<p>
  If you&#39;re using React, we&#39;ve wrapped approach #2 up into a simple
  LexicalComposer plugin that you can use to achieve the same effect, without
  worrying about the details:
</p>
<ul>
  <li>
    &lt; LexicalComposer &gt; &lt; NodeEventPlugin nodeType = { LinkNode }
    eventType = { &#39;click&#39; } eventListener = { ( e : Event ) =&gt; {
    alert ( &#39;Nice!&#39; ) ; } } /&gt; &lt;/ LexicalComposer &gt;
    <ol>
      <li>Event Delegation</li>
    </ol>
  </li>
  <li>
    <ol start="2">
      <li>Directly Attach Handlers</li>
    </ol>
  </li>
  <li>
    <ol start="3">
      <li>Use NodeEventPlugin</li>
    </ol>
  </li>
</ul>
