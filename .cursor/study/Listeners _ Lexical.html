<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="listeners">Listeners</h3>
<p>
  Listeners are a mechanism that lets the Editor instance inform the user when a
  certain operation has occurred. All listeners follow a reactive pattern where
  you can do an operation upon something happening in the future. All listeners
  also return a function that easily allows for the listener to be unregistered.
  Below are the different listeners that Lexical supports today:
</p>
<h4 id="registerupdatelistener">registerUpdateListener</h4>
<p>
  Get notified when Lexical commits an update to the DOM. const
  removeUpdateListener = editor . registerUpdateListener ( ( { editorState } )
  =&gt; { // The latest EditorState can be found as
  <code>editorState</code>
  . // To read the contents of the EditorState, use the following API:
  editorState . read ( ( ) =&gt; { // Just like editor.update(), .read() expects
  a closure where you can use // the $ prefixed helper functions. } ) ; } ) ; //
  Do not forget to unregister the listener when no longer needed!
  removeUpdateListener ( ) ;
</p>
<p>
  The update listener callbacks receives a single argument containing the follow
  properties:
</p>
<ul>
  <li>editorState the latest updated Editor State</li>
  <li>prevEditorState the previous Editor State</li>
  <li>
    tags a Set of all tags that were passed to the update One thing to be aware
    of is &#34;waterfall&#34; updates. This is where you might schedule an
    update inside an update listener, as shown below: editor .
    registerUpdateListener ( ( { editorState } ) =&gt; { // Read the editorState
    and maybe get some value. editorState . read ( ( ) =&gt; { // ... } ) ; //
    Then schedule another update. editor . update ( ( ) =&gt; { // ... } ) ; } )
    ;
  </li>
</ul>
<p>
  The problem with this pattern is that it means we end up doing two DOM
  updates, when we likely could have done it in a single DOM update. This can
  have an impact on performance, which is important in a text editor. To avoid
  this, we recommend looking into Node Transforms, which allow you to listen to
  node changes and transform them as part of the same given update, meaning no
  waterfalls!
</p>
<h4 id="registertextcontentlistener">registerTextContentListener</h4>
<p>
  Get notified when Lexical commits an update to the DOM and the text content of
  the editor changes from the previous state of the editor. If the text content
  is the same between updates, no notifications to the listeners will happen.
  const removeTextContentListener = editor . registerTextContentListener ( (
  textContent ) =&gt; { // The latest text content of the editor! console . log
  ( textContent ) ; } , ) ; // Do not forget to unregister the listener when no
  longer needed! removeTextContentListener ( ) ;
</p>
<h4 id="registermutationlistener">registerMutationListener</h4>
<p>
  Get notified when a specific type of Lexical node has been mutated. There are
  three states of mutation:
</p>
<ul>
  <li>created</li>
  <li>destroyed</li>
  <li>
    updated Mutation listeners are great for tracking the lifecycle of specific
    types of node. They can be used to handle external UI state and UI features
    relating to specific types of node. If any existing nodes are in the DOM,
    and skipInitialization is not true, the listener will be called immediately
    with an updateTag of &#39;registerMutationListener&#39; where all nodes have
    the &#39;created&#39; NodeMutation. This can be controlled with the
    skipInitialization option (whose default was previously true for backwards
    compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).
    const removeMutationListener = editor . registerMutationListener (
    MyCustomNode , ( mutatedNodes , { updateTags , dirtyLeaves , prevEditorState
    } ) =&gt; { // mutatedNodes is a Map where each key is the NodeKey, and the
    value is the state of mutation. for ( let [ nodeKey , mutation ] of
    mutatedNodes ) { console . log ( nodeKey , mutation ) } } , {
    skipInitialization : false } ) ; // Do not forget to unregister the listener
    when no longer needed! removeMutationListener ( ) ;
  </li>
</ul>
<h4 id="registereditablelistener">registerEditableListener</h4>
<p>
  Get notified when the editor&#39;s mode has changed. The editor&#39;s mode can
  be changed via editor.setEditable(boolean) . const removeEditableListener =
  editor . registerEditableListener ( ( editable ) =&gt; { // The editor&#39;s
  mode is passed in! console . log ( editable ) ; } , ) ; // Do not forget to
  unregister the listener when no longer needed! removeEditableListener ( ) ;
</p>
<h4 id="registerdecoratorlistener">registerDecoratorListener</h4>
<p>
  Get notified when the editor&#39;s decorator object changes. The decorator
  object contains all DecoratorNode keys -&gt; their decorated value. This is
  primarily used with external UI frameworks. const removeDecoratorListener =
  editor . registerDecoratorListener ( ( decorators ) =&gt; { // The
  editor&#39;s decorators object is passed in! console . log ( decorators ) ; }
  , ) ; // Do not forget to unregister the listener when no longer needed!
  removeDecoratorListener ( ) ;
</p>
<h4 id="registerrootlistener">registerRootListener</h4>
<p>
  Get notified when the editor&#39;s root DOM element (the content editable
  Lexical attaches to) changes. This is primarily used to attach event listeners
  to the root element.
  <em>
    The root listener function is executed directly upon registration and then
    on any subsequent update.
  </em>
</p>
<ul>
  <li>
    const removeRootListener = editor . registerRootListener ( ( rootElement ,
    prevRootElement ) =&gt; { //add listeners to the new root element //remove
    listeners from the old root element } , ) ; // Do not forget to unregister
    the listener when no longer needed! removeRootListener ( ) ;
    registerUpdateListener
  </li>
  <li>registerTextContentListener</li>
  <li>registerMutationListener</li>
  <li>registerEditableListener</li>
  <li>registerDecoratorListener</li>
  <li>registerRootListener</li>
</ul>
