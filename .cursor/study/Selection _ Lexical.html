<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="selection">Selection</h3>
<h4 id="types-of-selection">Types of selection</h4>
<p>
  Lexical&#39;s selection is part of the EditorState . This means that for every
  update, or change to the editor, the selection always remains consistent with
  that of the EditorState &#39;s node tree. In Lexical, there are four types of
  selection possible:
</p>
<ul>
  <li>RangeSelection</li>
  <li>NodeSelection</li>
  <li>TableSelection (implemented in @lexical/table )</li>
  <li>
    null It is possible, but not generally recommended, to implement your own
    selection types that implement BaseSelection .
  </li>
</ul>
<h5 id="rangeselection">RangeSelection</h5>
<p>
  This is the most common type of selection, and is a normalization of the
  browser&#39;s DOM Selection and Range APIs. RangeSelection consists of three
  main properties:
</p>
<ul>
  <li>anchor representing a RangeSelection point</li>
  <li>focus representing a RangeSelection point</li>
  <li>
    format numeric bitwise flag, representing any active text formats Both the
    anchor and focus points refer to an object that represents a specific part
    of the editor. The main properties of a RangeSelection point are:
  </li>
  <li>key representing the NodeKey of the selected Lexical node</li>
  <li>
    offset representing the position from within its selected Lexical node. For
    the text type this is the character, and for the element type this is the
    child index from within the ElementNode
  </li>
  <li>type representing either element or text .</li>
</ul>
<h5 id="nodeselection">NodeSelection</h5>
<p>
  NodeSelection represents a selection of multiple arbitrary nodes. For example,
  three images selected at the same time.
</p>
<ul>
  <li>getNodes() returns an array containing the selected LexicalNodes</li>
</ul>
<h5 id="tableselection">TableSelection</h5>
<p>
  TableSelection represents a grid-like selection like tables. It stores the key
  of the parent node where the selection takes place and the start and end
  points. TableSelection consists of three main properties:
</p>
<ul>
  <li>
    tableKey representing the parent node key where the selection takes place
  </li>
  <li>anchor representing a TableSelection point</li>
  <li>
    focus representing a TableSelection point For example, a table where you
    select row = 1 col = 1 to row 2 col = 2 could be stored as follows:
  </li>
  <li>tableKey = 2 table key</li>
  <li>anchor = 4 table cell (key may vary)</li>
  <li>
    focus = 10 table cell (key may vary) Note that anchor and focus points work
    the same way as RangeSelection .
  </li>
</ul>
<h5 id="null">null</h5>
<p>
  This is for when the editor doesn&#39;t have any active selection. This is
  common for when the editor has been blurred or when selection has moved to
  another editor on the page. This can also happen when trying to select
  non-editable components within the editor space.
</p>
<h4 id="working-with-selection">Working with selection</h4>
<p>
  Selection can be found using the $getSelection() helper, exported from the
  lexical package. This function can be used within an update, a read, or a
  command listener. import { $getSelection , SELECTION_CHANGE_COMMAND } from
  &#39;lexical&#39; ; editor . update ( ( ) =&gt; { const selection =
  $getSelection ( ) ; } ) ; editorState . read ( ( ) =&gt; { const selection =
  $getSelection ( ) ; } ) ; // SELECTION_CHANGE_COMMAND fires when selection
  changes within a Lexical editor. editor . registerCommand (
  SELECTION_CHANGE_COMMAND , ( ) =&gt; { const selection = $getSelection ( ) ; }
  ) ;
</p>
<p>
  In some cases you might want to create a new type of selection and set the
  editor selection to be that. This can only be done in update or command
  listeners. import { $setSelection , $createRangeSelection ,
  $createNodeSelection } from &#39;lexical&#39; ; editor . update ( ( ) =&gt; {
  // Set a range selection const rangeSelection = $createRangeSelection ( ) ;
  $setSelection ( rangeSelection ) ; // You can also indirectly create a range
  selection, by calling some of the selection // methods on Lexical nodes. const
  someNode = $getNodeByKey ( someKey ) ; // On element nodes, this will create a
  RangeSelection with type &#34;element&#34;, // referencing an offset relating
  to the child within the element. // On text nodes, this will create a
  RangeSelection with type &#34;text&#34;, // referencing the text character
  offset. someNode . select ( ) ; someNode . selectPrevious ( ) ; someNode .
  selectNext ( ) ; // You can use this on any node. someNode . selectStart ( ) ;
  someNode . selectEnd ( ) ; // Set a node selection const nodeSelection =
  $createNodeSelection ( ) ; // Add a node key to the selection. nodeSelection .
  add ( someKey ) ; $setSelection ( nodeSelection ) ; // You can also clear
  selection by setting it to
  <code>null</code>
  . $setSelection ( null ) ; } ) ;
</p>
<h4 id="focus">Focus</h4>
<p>
  You may notice that when you issue an editor.update or editor.dispatchCommand
  then the editor can &#34;steal focus&#34; if there is a selection and the
  editor is editable. This is because the Lexical selection is reconciled to the
  DOM selection during reconciliation, and the browser&#39;s focus follows its
  DOM selection. If you want to make updates or dispatch commands to the editor
  without changing the selection, can use the SKIP_DOM_SELECTION_TAG update tag
  (added in v0.22.0): // Call this from an editor.update or command listener
  $addUpdateTag ( SKIP_DOM_SELECTION_TAG ) ;
</p>
<p>
  If you want to add this tag during processing of a dispatchCommand , you can
  wrap it in an editor.update : // NOTE: If you are already in a command
  listener or editor.update, // do
  <em>not</em>
  nest a second editor.update! Nested updates have // confusing semantics
  (dispatchCommand will re-use the // current update without nesting) editor .
  update ( ( ) =&gt; { $addUpdateTag ( SKIP_DOM_SELECTION_TAG ) ; editor .
  dispatchCommand ( /* â€¦ */ ) ; } ) ;
</p>
<p>
  If you have to support older versions of Lexical, you can mark the editor as
  not editable during the update or dispatch.
</p>
<ul>
  <li>
    // NOTE: This code should be
    <em>outside</em>
    of your update or command listener, e.g. // directly in the DOM event
    listener const prevEditable = editor . isEditable ( ) ; editor . setEditable
    ( false ) ; editor . update ( ( ) =&gt; { // run your update code or
    editor.dispatchCommand in here } , { onUpdate : ( ) =&gt; { editor .
    setEditable ( prevEditable ) ; } , } , ) ; Types of selectionRangeSelection
  </li>
  <li>NodeSelection</li>
  <li>TableSelection</li>
  <li>null Working with selection Focus</li>
</ul>
