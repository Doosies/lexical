<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="key-management">Key Management</h3>
<p>
  Keys are a fundamental concept in Lexical that enable efficient state
  management and node tracking. Understanding how keys work is crucial for
  building reliable editor implementations.
</p>
<h4 id="what-are-keys">What are Keys?</h4>
<p>
  The __key property is a unique identifier assigned to each node in the Lexical
  editor. These keys are:
</p>
<ul>
  <li>Automatically generated by Lexical</li>
  <li>Used to track nodes in the editor state</li>
  <li>Essential for state management and updates</li>
  <li>Immutable during a node&#39;s lifecycle</li>
</ul>
<h4 id="when-to-use-__key">When to Use __key ?</h4>
<h5 id="correct-usage">✅ Correct Usage</h5>
<p>Keys should ONLY be used in two specific situations:</p>
<ol>
  <li>
    <p>
      <strong>In Node Constructors</strong>
      class MyCustomNode extends ElementNode { constructor ( someData : string ,
      key ? : NodeKey ) { super ( key ) ; // Correctly passing key to parent
      constructor this . __someData = someData ; } }
    </p>
  </li>
  <li>
    <p>
      <strong>In Static Clone Methods</strong>
      class MyCustomNode extends ElementNode { static clone ( node :
      MyCustomNode ) : MyCustomNode { return new MyCustomNode ( node .
      __someData , node . __key ) ; } }
    </p>
  </li>
</ol>
<h5 id="incorrect-usage">❌ Incorrect Usage</h5>
<p>
  Never use keys in these situations: // ❌ Don&#39;t pass keys between
  different nodes const newNode = new MyCustomNode ( existingNode . __key ) ; //
  ❌ Don&#39;t manipulate keys directly node . __key = &#39;custom-key&#39; ;
</p>
<h4 id="how-lexical-uses-keys">How Lexical Uses Keys</h4>
<h5 id="diagram">Diagram</h5>
<p>
  The dotted outlines show nodes that are re-used in a zero-copy fashion from
  one EditorState to the next
</p>
<h5 id="node-map-structure">Node Map Structure</h5>
<p>
  The EditorState maintains a Map&lt;NodeKey, LexicalNode&gt; that tracks all
  nodes. Nodes refer to each other using keys in their internal pointers: //
  Internal node structure (not for direct usage) { __prev : null | NodeKey ,
  __next : null | NodeKey , __parent : null | NodeKey , // __first, __last and
  __size are only for ElementNode to track its children __first : null | NodeKey
  , __last : null | NodeKey , __size : number }
</p>
<p>
  These internal pointers maintain the tree structure and should never be
  manipulated directly.
</p>
<h5 id="key-related-apis">Key-Related APIs</h5>
<ol>
  <li>
    <strong>Editor Methods</strong>
    // Get node by key const node = editor . getElementByKey ( key ) ; const
    node = $getNodeByKey ( key ) ; // Get latest version of a node const latest
    = node . getLatest ( ) ; // Get mutable version for updates const mutable =
    node . getWritable ( ) ;
  </li>
</ol>
<h5 id="key-lifecycle">Key Lifecycle</h5>
<p>
  NodeKeys are ephemeral and have several important characteristics:
  <strong>Serialization</strong>
</p>
<ul>
  <li>Keys are never serialized</li>
  <li>New keys are generated when deserializing (from JSON/HTML)</li>
  <li>
    Keys are only meaningful within their EditorState instance
    <strong>Uniqueness</strong>
  </li>
  <li>Keys are unique within an EditorState</li>
  <li>Current implementation uses serial numbers for debugging</li>
  <li>Should be treated as random and opaque values</li>
  <li>Never logically reused Keys are used internally by Lexical to:</li>
</ul>
<ol>
  <li>Track nodes in the editor state</li>
  <li>Manage node updates and versions</li>
  <li>Maintain referential integrity</li>
  <li>Enable efficient state updates</li>
</ol>
<h4 id="common-pitfalls">Common Pitfalls</h4>
<p><strong>Key Reuse</strong></p>
<ol>
  <li>
    // ❌ Never do this function duplicateNode ( node : LexicalNode ) { return
    new SameNodeType ( data , node . __key ) ; }
  </li>
</ol>
<p>
  <strong>Manual Key Assignment</strong>
  2. // ❌ Never do this node . __key = generateCustomKey ( ) ;
</p>
<p>
  <strong>Incorrect Constructor/Clone Implementation</strong>
  3. // ❌ Never do this - missing key in constructor class MyCustomNode extends
  ElementNode { constructor ( someData : string ) { super ( ) ; // Missing key
  parameter this . __someData = someData ; } } // ✅ Correct implementation
  class MyCustomNode extends ElementNode { __someData : string ; constructor (
  someData : string , key ? : NodeKey ) { super ( key ) ; this . __someData =
  someData ; } static clone ( node : MyCustomNode ) : MyCustomNode { return new
  MyCustomNode ( node . __someData , node . __key ) ; } afterCloneFrom (
  prevNode : this ) : void { super . afterCloneFrom ( prevNode ) ; this .
  __someData = prevNode . __someData ; } }
</p>
<p>
  <strong>Node Replacement</strong>
  // ❌ Never re-use the key when changing the node class const editorConfig = {
  nodes : [ CustomNodeType , { replace : OriginalNodeType , with : ( node :
  OriginalNodeType ) =&gt; new CustomNodeType ( node . __key ) , withKlass :
  CustomNodeType } ] } ; // ✅ Correct: Use node replacement configuration const
  editorConfig = { nodes : [ CustomNodeType , { replace : OriginalNodeType ,
  with : ( node : OriginalNodeType ) =&gt; new CustomNodeType ( ) , withKlass :
  CustomNodeType } ] } ;
</p>
<p>For proper node replacement, see the Node Replacement guide.</p>
<h4 id="best-practices">Best Practices</h4>
<ol>
  <li>
    <strong>Let Lexical Handle Keys</strong>
    import { $applyNodeReplacement } from &#39;lexical&#39; ; // Create node
    helper function export function $createMyCustomNode ( data : string ) :
    MyCustomNode { return $applyNodeReplacement ( new MyCustomNode ( data ) ) ;
    }
  </li>
</ol>
<h4 id="testing-considerations">Testing Considerations</h4>
<p>
  When writing tests involving node keys: test ( &#39;node creation&#39; , async
  ( ) =&gt; { await editor . update ( ( ) =&gt; { // ✅ Correct: Create nodes
  normally const node = new MyCustomNode ( &#34;test&#34; ) ; // ✅ Correct:
  Keys are automatically handled expect ( node . __key ) . toBeDefined ( ) ;
  expect ( node . __key ) . not . toBe ( &#39;&#39; ) ; } ) ; } ) ;
</p>
<h4 id="performance-impact">Performance Impact</h4>
<p>Understanding key management is crucial for performance:</p>
<ol>
  <li>Keys enable efficient node lookup (O(1))</li>
  <li>Proper key usage prevents unnecessary re-renders</li>
  <li>Lexical&#39;s key system optimizes state updates</li>
  <li>Improper key manipulation can cause performance issues</li>
</ol>
<h4 id="common-questions">Common Questions</h4>
<p>
  <strong>Q: How do I reference a node later?</strong>
  A: Store a reference to the node. Conventionally, all node methods will use
  getLatest() or getWritable() which will look up the latest version of that
  node before reading or writing its properties, which is equivalent to using
  the key but is type-safe (but may cause errors if you try to use a reference
  to a node that no longer exists). In some situations it may be preferable to
  use the key directly, which is also fine.
  <strong>Q: How do I ensure unique nodes?</strong>
  A: Let Lexical handle key generation and management. Focus on node content and
  structure.
</p>
<ul>
  <li>What are Keys?</li>
  <li>When to Use __key ?✅ Correct Usage</li>
  <li>❌ Incorrect Usage</li>
  <li>How Lexical Uses KeysDiagram</li>
  <li>Node Map Structure</li>
  <li>Key-Related APIs</li>
  <li>
    Key Lifecycle Common Pitfalls Best Practices Testing Considerations
    Performance Impact Common Questions
  </li>
</ul>
