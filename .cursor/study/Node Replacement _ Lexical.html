<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="node-replacement">Node Replacement</h3>
<p>
  Node Replacement allow you to replace all instances of a given node in your
  editor with instances of a subclass.
</p>
<h4 id="use-case">Use Case</h4>
<p>
  note In earlier versions of this documentation, &#34;Node Replacement&#34; was
  called &#34;Node Overrides&#34;. We&#39;ve changed the name to match the terms
  used in the implementation. tip If your use case only requires adding ad-hoc
  data to existing nodes, you may be able to use the NodeState API instead of
  subclassing and node replacement. Some of the most commonly used Lexical Nodes
  are owned and maintained by the core library. For example, ParagraphNode,
  HeadingNode, QuoteNode, List(Item)Node etc - these are all provided by Lexical
  packages, which provides an easier out-of-the-box experience for some editor
  features, but makes it difficult to override their behavior. For instance, if
  you wanted to change the behavior of ListNode, you would typically extend the
  class and override the methods. However, how would you tell Lexical to use
  <em>your</em>
  ListNode subclass in the ListPlugin instead of using the core ListNode?
  That&#39;s where Node Replacement can help. Node Replacement allow you to
  replace all instances of a given node in your editor with instances of a
  different node class. This can be done through the nodes array in the Editor
  config: const editorConfig = { ... nodes = [ // Don&#39;t forget to register
  your custom node separately! CustomParagraphNode , { replace : ParagraphNode ,
  with : ( node : ParagraphNode ) =&gt; { return $createCustomParagraphNode ( )
  ; } , withKlass : CustomParagraphNode , } ] }
</p>
<p>In the snippet above,</p>
<ul>
  <li>replace : Specifies the core node type to be replaced.</li>
  <li>
    with : Defines a transformation function to replace instances of the
    original node to the custom node.
  </li>
  <li>
    withKlass : This option ensures that behaviors associated with the original
    node type work seamlessly with the replacement. For instance, node
    transforms or mutation listeners targeting ParagraphNode will also apply to
    CustomParagraphNode when withKlass is specified. Without this option, the
    custom node might not fully integrate with the editor&#39;s built-in
    features, leading to unexpected behavior. Once this is done, Lexical will
    replace all ParagraphNode instances with CustomParagraphNode instances. One
    important use case for this feature is overriding the serialization behavior
    of core nodes. Check out the full example below.
  </li>
</ul>
<h4 id="node-replacement-example">Node Replacement Example</h4>
<p>
  This example demonstrates using Node Replacement to replace all ParagraphNode
  with a CustomParagraphNode that overrides createDOM .
</p>
<ul>
  <li>Use Case</li>
  <li>Node Replacement Example</li>
</ul>
