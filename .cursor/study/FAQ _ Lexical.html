<p>Skip to main contentPlaygroundDocsAPICommunityiOSGalleryGitHubiOS GitHub</p>
<h3 id="faq">FAQ</h3>
<h4 id="why-does-lexical-use-the-prefix-in-the-name-of-many-of-the-functions">
  Why does Lexical use the $ prefix in the name of many of the functions?
</h4>
<p>
  Originally, Lexical didn&#39;t have $ functions, instead these functions were
  provided to you through callback params: // Mid 2020 API editor . update ( (
  viewState ) =&gt; { const getRoot = viewState . getRoot ( ) ; . . } ) ; editor
  . addTextTransform ( ( viewState ) =&gt; { const getRoot = viewState . getRoot
  ( ) ; . . } ) ;
</p>
<p>Internally, this approach raised some negative feedback:</p>
<ul>
  <li>
    The viewState terminology was confusing. It wasn&#39;t really a viewState ,
    more like a toolkit to manipulate the EditorState
  </li>
  <li>
    For complex updates and transforms devs had to carry params around on many
    layers This is when we decided to leverage the &#34;lexical&#34; scope
    instead to perform EditorState manipulation, and the $ represents just that.
    editor . update ( ( ) =&gt; ... ) ; editor . registerNodeTransform ( FooNode
    , ( ) =&gt; ... ) ; editor . getEditorState ( ) . read ( ... ) ;
  </li>
</ul>
<p>
  If you&#39;ve used React Hooks before, you can think of $ functions as being
  something that follows a similar pattern. These are functions that show their
  intent as to where they can or cannot be used. This makes it possible for a
  developer to create their own functions that give the same signal, by simply
  prefixing the function with the dollar. Internally, we&#39;ve found this
  scales really well and developers get to grips with it in almost no time at
  all.
</p>
<h4 id="when-does-reconciliation-happen">When does reconciliation happen?</h4>
<p>
  Reconciliation is scheduled with queueMicrotask, which means that it will
  happen very soon, but asynchronously. This is similar to something like
  setTimeout(reconcile, 0) with a bit more immediacy or
  Promise.resolve().then(reconcile) with less overhead. This is done so that all
  of the updates that occur as a result of a single logical event will be
  batched into one reconciliation. You can force a reconciliation to take place
  synchronously with the discrete option to editor.update (demonstrated below).
</p>
<h4 id="why-do-tests-use-await-editor-update">
  Why do tests use await editor.update(…)
</h4>
<p>
  You may notice that many tests look like this: await editor . update ( updateA
  ) ; await editor . update ( updateB ) ;
</p>
<p>
  An astute observer would notice that this seems very strange, since
  editor.update() returns void and not Promise
</p>
<p>At a high level, very roughly, the order of operations looks like this:</p>
<ol>
  <li>editor.update() is called</li>
  <li>updateA() is called and updates the editor state</li>
  <li>editor.update() schedules a reconciliation microtask and returns</li>
  <li>
    await schedules a resume microtask and yields control to the task executor
  </li>
  <li>
    the reconciliation microtask runs, reconciling the editor state with the DOM
  </li>
  <li>the resume microtask runs</li>
</ol>
<h4 id="how-do-i-listen-for-user-text-insertions">
  How do I listen for user text insertions?
</h4>
<p>
  Listening to text insertion events is problematic with content editables in
  general. It&#39;s a common source of bugs due to how different browsers and
  third-party extensions interact with the DOM. Whilst it&#39;s possible to use
  DOM events like input and beforeinput to gauge some of the possible cases
  where a user has inserted text, these are hardly reliable and also don&#39;t
  take into account edge-cases. Instead, Lexical prefers to consider any change
  as a possible user input, and as such doesn&#39;t make a distinction between
  the cases. This is important for tools like spellcheck, browser extensions,
  IME, speech-to-text, screen readers and other external tools that often
  don&#39;t reliably trigger a reliable event sequence (some don&#39;t even
  trigger any events at all!). For those wanting to react to a text change and
  possibly block/alter the intent, the recommended approach is to use a node
  transform. This also plays nicely with other sub-systems at play that might
  also be looking to do the same thing as you. For those who just want to know
  of the changes, this can be achieved using a text content listener or an
  editor update listener.
</p>
<h4 id="how-do-i-clear-the-contents-of-the-editor">
  How do I clear the contents of the editor?
</h4>
<p>
  You can go this by calling clear() on the RootNode in an update callback:
  editor . update ( ( ) =&gt; { $getRoot ( ) . clear ( ) ; } )
</p>
<h4 id="how-do-i-listen-to-specific-key-down-events">
  How do I listen to specific key down events?
</h4>
<p>
  You can leverage Lexical&#39;s command listening system. Lexical provides
  specific commands for many common keyboard operations, such as:
</p>
<ul>
  <li>KEY_ARROW_LEFT_COMMAND</li>
  <li>KEY_ARROW_RIGHT_COMMAND</li>
  <li>KEY_ARROW_UP_COMMAND</li>
  <li>KEY_ARROW_DOWN_COMMAND</li>
  <li>KEY_SPACE_COMMAND</li>
  <li>KEY_ENTER_COMMAND</li>
  <li>KEY_BACKSPACE_COMMAND</li>
  <li>KEY_DELETE_COMMAND</li>
  <li>KEY_TAB_COMMAND</li>
  <li>
    KEY_ESCAPE_COMMAND import { KEY_ENTER_COMMAND , COMMAND_PRIORITY_LOW } from
    &#39;lexical&#39; ; editor . registerCommand ( KEY_ENTER_COMMAND , ( event :
    KeyboardEvent ) =&gt; { // Handle enter key presses here return false ; } ,
    COMMAND_PRIORITY_LOW )
  </li>
</ul>
<p>
  You can use the generic KEY_DOWN_COMMAND command to listen to all keydown
  events. Do note, that returning true in your listener will prevent any other
  key based commands from firing, so in most cases you&#39;ll want to return
  false from the command listener. import { KEY_DOWN_COMMAND ,
  COMMAND_PRIORITY_LOW } from &#39;lexical&#39; ; editor . registerCommand (
  KEY_DOWN_COMMAND , ( event : KeyboardEvent ) =&gt; { // Handle event here
  return false ; } , COMMAND_PRIORITY_LOW ) tip If you do return true from any
  listener with an event payload, you likely also should call
  event.preventDefault() unless your command relies on the browser&#39;s native
  processing of that event.
</p>
<ul>
  <li>
    Why does Lexical use the $ prefix in the name of many of the functions?
  </li>
  <li>When does reconciliation happen?</li>
  <li>Why do tests use await editor.update(…)</li>
  <li>How do I listen for user text insertions?</li>
  <li>How do I clear the contents of the editor?</li>
  <li>How do I listen to specific key down events?</li>
</ul>
