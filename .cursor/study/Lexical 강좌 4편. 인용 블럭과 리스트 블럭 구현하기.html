<h3 id="lexical-4">Lexical 강좌 4편. 인용 블럭과 리스트 블럭 구현하기</h3>
<p>
  안녕하세요? 오늘은 Lexical 강좌 4편을 이어가도록 하겠습니다. 전체 강좌
  리스트입니다. Lexical 강좌 1편. 간단한 소개와 기본적인 구현 Lexical 강좌 2편.
  플러그인 구현과 undo, redo 기능 추가하기 Lexical 강좌 3편. H1, H2 같은
  Headings 구현 Lexical 강좌 4편. 인용 블럭과 리스트 블럭 구현하기 Lexical 강좌
  5편. 코드 블럭 구현과 인라인 스타일, 마크다운과 같은 단축기 구현하기 ** 목 차
  **
</p>
<ul>
  <li>Lexical 강좌 4편. 인용 블럭과 리스트 블럭 구현하기인용 블록 구현하기</li>
  <li>리스트 블록 구현하기</li>
</ul>
<h4 id="-">인용 블록 구현하기</h4>
<p>
  인용 블록도 리치 텍스트 에디터의 가장 기본적인 기능인데요. HTML의 blockquote에
  해당하는 블록으로, 다른 사람의 발언이나 글을 소개할 때 사용합니다.
  Lexical에서는 HeadingNode를 추가하는 절차와 완전히 같습니다. 간단하게
  만들어봅시다. LexicalEditor에 QuoteNode를 등록합니다. QuoteNode 클래스는
  @lexical/rich-text 패키지에 포함되어 있습니다. // src/nodes.ts import {
  HeadingNode , QuoteNode } from &#34;@lexical/rich-text&#34; ; import { Klass ,
  LexicalNode } from &#34;lexical&#34; ; export const nodes : Klass &lt;
  LexicalNode &gt;[] = [ HeadingNode , QuoteNode ]; SupportedBlockType에 quote
  속성을 추가합니다. // src/plugins/ToolbarPlugin.tsx const SupportedBlockType =
  { paragraph : &#34;Paragraph&#34; , h1 : &#34;Heading 1&#34; , h2 :
  &#34;Heading 2&#34; , h3 : &#34;Heading 3&#34; , h4 : &#34;Heading 4&#34; , h5
  : &#34;Heading 5&#34; , h6 : &#34;Heading 6&#34; , quote : &#34;Quote&#34; , }
  as const ; QuoteNode로 변환하는 함수와 그것을 클릭으로 실행하는 툴바 버튼을
  준비합니다. $createQuoteNode 도 @lexical/rich-text 패키지에서 import할 수
  있습니다. // src/plugins/ToolbarPlugin.tsx // 생략 import { MdFormatQuote }
  from &#34;react-icons/md&#34; ; export const ToolbarPlugin : FC = () =&gt; {
  // 생략 const formatQuote = useCallback ( () =&gt; { if (blockType !==
  &#34;quote&#34; ) { editor. update ( () =&gt; { const selection =
  $getSelection(); if ($isRangeSelection(selection)) { $setBlocksType(selection,
  () =&gt; $createQuoteNode()); } }); } }, [blockType, editor]); // 생략 return
  ( &lt; div className = {styles.toolbar} &gt; {/
  <em>생략</em>
  /} &lt; button type = &#34;button&#34; role = &#34;checkbox&#34; title =
  {SupportedBlockType[ &#34; quote &#34;]} aria-label = {SupportedBlockType[
  &#34; quote &#34;]} aria-checked = {blockType === &#34;quote&#34; } onClick =
  {formatQuote} &gt; &lt; MdFormatQuote /&gt; &lt;/ button &gt; &lt;/ div &gt;
  ); }; QuoteNode는 .getType() 으로 &#34;quote&#34; 문자열을 얻을 수 있으므로,
  setBlockType으로 블록 타입을 업데이트하는 useEffect는 수정할 필요가 없습니다.
  QuoteNode가 에디터 상에 렌더링하는 blockquote에 적용할 클래스명을 설정합니다.
  src/editorTheme. ts export const theme : EditorThemeClasses = { heading : { /
  <em>생략</em>
  / }, quote : styles. quote , }; 이제 인용 블록을 사용할 수 있게 되었습니다!
  실행 결과는 아래와 같습니다.
</p>
<h4 id="--2">리스트 블록 구현하기</h4>
<p>
  리스트 블록이란 HTML에서는 ul, ol, li에 해당하는 블록입니다. 일반적으로 리치
  텍스트 에디터에는 중첩된 리스트를 입력할 수 있는 기능이 있어야합니다. 하지만,
  그걸 구현하기 위해서는 상당히 복잡한 상태 관리 처리를 작성해야 하는데요. 꽤나
  어렵습니다. 그러나 Meta 엔지니어의 세심한 배려로 undo redo 등과 같이 공식
  플러그인을 삽입하기만 하면 로직이 쉽게 구현되는데요. 덤으로 GitHub의
  Markdown에 있는 것처럼 체크리스트도 구현할 수 있습니다. 이제 순서 있는
  리스트(Ordered List), 순서 없는 리스트(Unordered List), 체크 리스트(Check
  List)를 차례대로 구현해 볼까요? 먼저 Node 클래스를 등록합니다. 리스트 기능용
  Node 클래스는 ListNode와 ListItemNode 두 가지로 나뉘며, 둘 다 @lexical/list
  에서 import할 수 있습니다. // src/nodes.ts import { HeadingNode , QuoteNode }
  from &#34;@lexical/rich-text&#34; ; import { ListItemNode , ListNode } from
  &#34;@lexical/list&#34; ; import { Klass , LexicalNode } from
  &#34;lexical&#34; ; export const nodes : Klass &lt; LexicalNode &gt;[] = [
  HeadingNode , QuoteNode , ListItemNode , ListNode , ]; 그리고 앞서 언급한
  복잡한 리스트 로직을 구현해주는 공식 플러그인을 사용합시다. // src/Editor.tsx
  // 생략 import { CheckListPlugin } from
  &#34;@lexical/react/LexicalCheckListPlugin&#34; ; import { ListPlugin } from
  &#34;@lexical/react/LexicalListPlugin&#34; ; export const Editor : FC = ()
  =&gt; { return ( &lt; LexicalComposer initialConfig = {initialConfig} &gt; {/
  <em>생략</em>
  /} &lt; ListPlugin /&gt; &lt; CheckListPlugin /&gt; &lt;/ LexicalComposer &gt;
  ); }; 위와 같이 CheckListPlugin과 ListPlugin를 적용하면 됩니다. 체크리스트
  기능이 필요 없다면 ListPlugin만 적용하면 됩니다. 이어서 ToolbarPlugin을
  편집하여 버튼을 클릭하면 리스트 블록으로 변환할 수 있도록 해야 합니다. //
  src/plugins/ToolbarPlugin.tsx const SupportedBlockType = { // 생략 number :
  &#34;Numbered List&#34; , bullet : &#34;Bulleted List&#34; , check :
  &#34;Check List&#34; , } as const ; 순서 있는 리스트는 number 블록이고, 순서
  없는 리스트는 bullet 블록입니다. 위와 같이 하면 listNode.getListType() 의
  반환값과 일치하기 때문에 다루기 쉽습니다. 이제 현재 Selection이 가리키는
  블록을 각각의 리스트 블록으로 변환하는 처리를 작성해야 합니다. //
  src/plugins/ToolbarPlugin.tsx // 생략 import { INSERT_UNORDERED_LIST_COMMAND ,
  INSERT_ORDERED_LIST_COMMAND , INSERT_CHECK_LIST_COMMAND , } from
  &#34;@lexical/list&#34; ; // 생략 const formatBulletList = useCallback ( ()
  =&gt; { if (blockType !== &#34;bullet&#34; ) { editor. dispatchCommand (
  INSERT_UNORDERED_LIST_COMMAND , undefined ); } }, [blockType, editor]); const
  formatNumberedList = useCallback ( () =&gt; { if (blockType !==
  &#34;number&#34; ) { editor. dispatchCommand ( INSERT_ORDERED_LIST_COMMAND ,
  undefined ); } }, [blockType, editor]); const formatCheckList = useCallback (
  () =&gt; { if (blockType !== &#34;check&#34; ) { editor. dispatchCommand (
  INSERT_CHECK_LIST_COMMAND , undefined ); } }, [blockType, editor]);
  INSERT_UNORDERED_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND,
  INSERT_CHECK_LIST_COMMAND은 @lexical/list 패키지에서 import할 수 있습니다.
  editor.dispatchCommand가 등장했습니다. Flux 아키텍처에서 Action을 dispatch하면
  reducer가 새로운 state를 생성하는 것처럼, Lexical에서는 Command를 dispatch하면
  미리 등록된 처리(editor.registerCommand)가 실행되어 EditorState가
  업데이트됩니다. 위 코드에서는 Command를 dispatch하는 부분을 수행하고 있습니다.
  dispatch된 INSERT_UNORDERED_LIST_COMMAND 등의 Command에 대응하는 처리는
  어디에서 등록되어 있을까요? 바로 앞서 삽입한 ListPlugin 내부에서 등록되어
  있습니다. ListPlugin 내부(useList가 호출되는 부분) //
  facebook/lexical/packages/lexical-react/src/LexicalListPlugin.ts export
  function ListPlugin ( ): null { const [editor] = useLexicalComposerContext ();
  useEffect ( () =&gt; { if (!editor. hasNodes ([ ListNode , ListItemNode ])) {
  throw new Error ( &#39;ListPlugin: ListNode and/or ListItemNode not registered
  on editor&#39; , ); } }, [editor]); useList (editor); return null ; }
  useList의 구현(editor.registerCommand가 호출되는 부분) //
  facebook/lexical/packages/lexical-react/src/shared/useList.ts export function
  useList ( editor: LexicalEditor ): void { useEffect ( () =&gt; { return
  mergeRegister ( editor. registerCommand ( INDENT_CONTENT_COMMAND , () =&gt; {
  indentList (); return false ; }, COMMAND_PRIORITY_LOW , ), editor.
  registerCommand ( OUTDENT_CONTENT_COMMAND , () =&gt; { outdentList (); return
  false ; }, COMMAND_PRIORITY_LOW , ), editor. registerCommand (
  INSERT_ORDERED_LIST_COMMAND , () =&gt; { insertList (editor, &#39;number&#39;
  ); return true ; }, COMMAND_PRIORITY_LOW , ), editor. registerCommand (
  INSERT_UNORDERED_LIST_COMMAND , () =&gt; { insertList (editor,
  &#39;bullet&#39; ); return true ; }, COMMAND_PRIORITY_LOW , ), editor.
  registerCommand ( REMOVE_LIST_COMMAND , () =&gt; { removeList (editor); return
  true ; }, COMMAND_PRIORITY_LOW , ), editor. registerCommand (
  INSERT_PARAGRAPH_COMMAND , () =&gt; { const hasHandledInsertParagraph =
  $handleListInsertParagraph(); if (hasHandledInsertParagraph) { return true ; }
  return false ; }, COMMAND_PRIORITY_LOW , ), ); }, [editor]); } 플러그인에서
  Command에 대한 상태 업데이트 처리를 등록해주기 때문에, dispatch만 하면 알아서
  블록 변환을 해줍니다. Flux에서 Action에 payload를 함께 dispatch할 수 있듯이,
  Lexical의 dispatchCommand에서는 두 번째 인자가 그 역할을 합니다. 이번에는
  3개의 Command 모두 LexicalCommand
</p>
<h5 id="lexicalquote-blocklist-block-lexical-5-lexical-3-h1-h2-headings">
  lexicalquote blocklist block다음 글 : Lexical 강좌 5편. 코드 블럭 구현과
  인라인 스타일, 마크다운과 같은 단축기 구현하기목록 보기이전 글 : Lexical 강좌
  3편. H1, H2 같은 Headings 구현
</h5>
