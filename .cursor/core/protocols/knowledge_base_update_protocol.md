# Knowledge Base Update Protocol (지식 베이스 업데이트 프로토콜)
# version: 2.0

## Description
[PROTOCOL] 지식 베이스의 문서를 추가하거나 수정할 때 반드시 따라야 하는 절차입니다. 이 프로토콜은 "그냥 만들지 않고", 기존 지식과의 관계를 파악하여 지식 베이스 전체의 일관성과 연결성을 보장하는 것을 목표로 합니다.

---

## Steps (실행 단계)

### **Step 1: 분류 (Classification)**
- **Goal:** 저장할 정보의 성격과 주제를 분석하여, 지식 베이스 내에서 어떤 종류의 지식에 해당하는지 결정합니다.
- **Action:**
    - 정보의 성격과 주제를 분석하여 아래 테이블의 기준에 맞춰 저장할 최적의 대분류 폴더(e.g. `/analysis`, `/guidelines`)를 결정합니다.
    - 필요 시 `3의 법칙`이나 `기능 단위` 휴리스틱에 따라 새 하위 폴더 생성을 고려합니다.
- **Detailed Guidelines:**
    | 디렉토리           | 핵심 질문 (Key Question)                   | 목적                                                                       |
    | :----------------- | :----------------------------------------- | :------------------------------------------------------------------------- |
    | `/project_context` | **"이 프로젝트는 무엇인가? (What is this project?)"** | 프로젝트의 목표, 기술 스택, 현재 상태 등 **핵심 정체성**을 정의합니다.      |
    | `/analysis`        | **"어떻게 동작하는가? (How does it work?)"**       | 내부 동작 원리, 아키텍처, 디자인 철학 등 **개념과 원리**를 심층 분석합니다. |
    | `/guidelines`      | **"어떻게 사용해야 하는가? (How to use it?)"**      | API 사용법, 모범 사례, 단계별 절차 등 **실용적인 개발 지침**을 제공합니다.   |
    | `/decisions`       | **"왜 이렇게 만들었는가? (Why did we build it this way?)"** | 중요한 기술적 결정과 그 배경을 ADR(Architecture Decision Record) 형식으로 기록합니다. |
    | `/examples`        | **"어떻게 구현하는가? (How to implement it?)"**    | 특정 기능을 구현하는 구체적이고 바로 실행 가능한 코드 예제를 제공합니다.     |
    | `/deep_dives`      | **"특정 주제를 깊게 파보자 (Let's deep dive)"** | `analysis`보다 더 세부적이거나 특정 기술에 국한된 탐구 내용을 기록합니다.     |

### **Step 2: 위치 및 유사성 분석 (Location & Similarity Analysis) [매우 중요]**
- **Goal:** 새 정보를 배치할 최적의 위치를 찾고, 이미 존재하는 유사한 정보가 있는지 확인합니다.
- **Action:**
    1.  `[TOOL: codebase_search]` 또는 `index.yaml` 재귀 탐색을 통해, Step 1에서 결정된 대분류 폴더 내에서 새 정보와 관련성이 높은 기존 문서나 하위 폴더가 있는지 탐색합니다.
    2.  검색된 문서들의 요약(`index.yaml`)이나 핵심 내용(`read_file`)을 분석하여, 새 정보와 얼마나 유사한지, 또는 어떤 관계가 있는지 파악합니다.

### **Step 3: 실행 전략 수립 (Execution Strategy Formulation)**
- **Goal:** 분석 결과를 바탕으로, 지식 베이스의 가치를 가장 높일 수 있는 최적의 실행 전략을 결정합니다.
- **Action:** 아래 세 가지 전략 중 하나를 선택하고, 그 근거를 명확히 합니다.
    1.  **수정 (Update):**
        - **조건:** 기존 문서가 새 정보의 내용을 거의 포함하고 있으며, 약간의 보강만으로 충분할 때.
        - **실행:** 새 파일을 만들지 않고, 기존 파일을 직접 수정하여 정보를 최신화합니다.
    2.  **생성 (Create):**
        - **조건:** 새 정보가 기존 문서들과 주제가 명확히 다르거나, 독립적으로 존재해야 할 중요한 정보일 때.
        - **실행:** Step 2에서 찾은 최적의 위치에 새 파일을 생성합니다.
    3.  **생성 및 연결 (Create & Link):**
        - **조건:** 새 정보가 독립적인 문서로 존재할 가치가 있지만, Step 2에서 분석한 여러 기존 문서와 강한 연관성이 있을 때.
        - **실행:** 새 파일을 생성한 후, 관련된 모든 기존 문서를 수정하여 새 문서로의 참조(마크다운 링크)를 추가합니다.

### **Step 4: 계획 실행 (Execute Plan)**
- **Goal:** 수립된 전략에 따라 실제 파일 시스템에 변경을 적용합니다.
- **Action:** `수정`, `생성`, `생성 및 연결` 전략에 필요한 `write` 또는 `search_replace` 도구를 실행합니다.

### **Step 5: 내용 보강 및 상호 연결 (Content Enrichment & Cross-linking)**
- **Goal:** 개별 지식의 고립을 방지하고, 지식 베이스를 유기적인 네트워크로 만듭니다.
- **Action:** (전략이 '생성 및 연결'이 아니었더라도) 작성된 문서의 본문을 다시 검토하여, 관련된 다른 문서로 연결되는 마크다운 링크를 추가할 부분이 있는지 확인하고 보강합니다.

### **Step 6: 목차 관리 (Index Management)**
- **Goal:** `index.yaml`을 항상 최신 상태로 유지하여, AI가 전체 구조를 정확히 파악하도록 합니다.
- **Action:** `on_create_file`, `on_update_file`, `on_delete` 등 파일 시스템 변경에 맞춰 `index.yaml`의 `documents` 또는 `directories` 리스트를 정확하게 업데이트합니다.

### **Step 7: README 생성 및 업데이트 (README Generation & Update)**
- **Goal:** 개발자가 폴더의 내용을 쉽게 파악할 수 있도록, `README.md` 파일을 항상 최신 상태로 유지합니다.
- **Action:** 방금 업데이트된 `index.yaml` 파일의 내용을 바탕으로, 해당 디렉토리의 `README.md` 파일을 자동으로 생성하거나 업데이트합니다.
