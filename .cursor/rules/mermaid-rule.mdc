# Mermaid 다이어그램 작성 가이드라인

이 문서는 프로젝트 내에서 Mermaid 다이어그램을 작성할 때 발생하는 일반적인 파싱 오류를 방지하고, 코드의 일관성과 가독성을 높이기 위한 규칙을 정의합니다.

---

## 1. 기본 문법 (Basic Syntax)

다이어그램의 정확한 렌더링을 위해 반드시 지켜야 할 기본적인 문법 규칙입니다.

### 1.1. 텍스트는 항상 큰따옴표(`"`)로 감싸기

-   **이유**: 텍스트에 공백, 특수문자(`.`, `()`, `<br/>` 등) 또는 Mermaid **예약어(`graph`, `subgraph`, `end` 등)**가 포함되면 파서가 오류를 일으킵니다. 큰따옴표는 해당 부분을 단순 문자열로 처리하도록 강제합니다.
-   **[예외]**: `classDef` 선언부의 스타일 속성값(e.g., `#444`, `1px`)에는 큰따옴표를 사용하지 않습니다.
-   **✅ 올바른 예시**: `A["main.ts"] --> B["runAction()"];`
-   **✅ 올바른 예시**: `classDef primary fill:#2E6E9E,stroke:#1C4E7A,color:#fff`
-   **❌ 잘못된 예시**: `A(main.ts) --> B(runAction());`
-   **❌ 잘못된 예시**: `classDef primary fill:"#2E6E9E"`

### 1.2. 특수 문자 이스케이프 처리

-   **이유**: 노드 텍스트에 렌더러가 특별한 의미로 해석할 수 있는 문자(e.g., `<>`)가 포함되면 렌더링이 깨질 수 있습니다. 또한, 숫자로 시작하는 텍스트는 마크다운 목록으로 잘못 해석될 수 있습니다.
-   **해결책**: 해당 문자를 이스케이프(escape) 처리하여 일반 텍스트임을 명시해야 합니다.
    -   꺾쇠 기호 (`<`, `>`): HTML 엔티티 코드를 사용합니다. (`<` → `&lt;`, `>` → `&gt;`)
    -   숫자 목록 패턴 (`1.`, `2.` 등): 점(`.`) 앞에 백슬래시(`\`)를 사용합니다.
-   **✅ 예시**: `A["&lt;Component&gt;"]`, `B["1\. First Step"]`
-   **❌ 잘못된 예시**: `A["<Component>"]`, `B["1. First Step"]`

### 1.3. 다이어그램 종류에 맞는 링크 스타일 사용

-   **이유**: 각 다이어그램(`graph`, `classDiagram`, `stateDiagram` 등)은 고유한 링크(화살표) 문법을 가집니다. 다른 종류의 문법을 혼용하면 문법 오류가 발생합니다.
-   **✅ 올바른 예시 (일반 선)**: `graph TD`에서는 `-->` 또는 `-- "텍스트" -->` 사용
    ```mermaid
    graph TD
        A["React Component"] -- "핸들 노출" --> B["useImperativeHandle"];
    ```
-   **✅ 올바른 예시 (점선)**: 텍스트가 있는 점선은 `-. "텍스트" .->` 형식을 사용합니다.
    ```mermaid
    graph TD
        A["PLANNING"] -. "계획 수정" .-> B["PLANNING"];
    ```
-   **❌ 잘못된 예시**: `graph TD`에서 `classDiagram`용 상속 화살표(`--|>`) 사용
    ```mermaid
    graph TD
        A["React Component"] --|> B["useImperativeHandle"];
    ```
-   **❌ 잘못된 예시 (잘못된 점선)**: 존재하지 않는 문법을 혼합하여 사용.
    ```mermaid
    graph TD
        A["PLANNING"] -- "계획 수정" -.-> B["PLANNING"];
    ```

---

## 3. 구조화 가이드 (Structuring Guide)

다이어그램의 가독성과 유지보수성을 높이기 위한 구조 작성법입니다.

### 3.1. 노드 선언과 관계 연결 분리

-   **원칙**: 모든 노드와 서브그래프(`subgraph`) 선언이 끝난 후, 다이어그램의 **최하단에 관계 연결(linking) 부분을 모아서 작성**합니다.
-   **[중요]**: **각 관계 연결은 반드시 개별적인 줄(Newline)에 작성해야 합니다.** 두 개 이상의 연결을 한 줄에 작성하면 `Lexical error`가 발생합니다.
-   **✅ 권장 방식**:

    ```mermaid
    graph TD
        %% 1. 모든 노드와 서브그래프를 먼저 선언합니다.
        subgraph "Group A"
            A["Node A"]
            B["Node B"]
        end
        subgraph "Group B"
            C["Node C"]
        end

        %% 2. 관계 연결은 최하단에 모아서 작성합니다.
        A -- "연결 1" --> B
        B -- "연결 2" --> C
    ```

-   **❌ 잘못된 예시**:
    ```mermaid
    graph TD
        A --> B C --> D
    ```

### 3.2. 레이아웃 방향 선택 (TD vs LR)

-   **목적**: 다이어그램의 목적과 정보 흐름에 가장 적합한 방향을 선택합니다.
-   **`graph TD` (Top to Down)**: **수직적 계층, 순차적 프로세스, 시간의 흐름** 표현에 적합합니다. (예: 작업 흐름도, 컴포넌트 트리)
-   **`graph LR` (Left to Right)**: **시스템 간의 수평적 상호작용, 역할 비교** 표현에 적합합니다. (예: 클라이언트-서버 아키텍처, 마이크로서비스 통신)

---

## 4. 디자인 시스템 (Design System)

디자이너, 프롬프트 엔지니어와의 협업을 통해 다크(Dark) 테마 환경에서의 가독성과 통일성을 높이는 디자인 규칙을 수립했습니다. 모든 다이어그램은 이 규칙을 따라야 합니다.

### 4.1. 핵심 디자인 원칙

-   **가독성 우선**: 배경색과 텍스트 색상은 명확한 대비를 이루어야 합니다.
-   **의미론적 디자인**: 노드의 역할과 중요도에 따라 지정된 색상과 모양을 사용하여 의미를 시각적으로 전달합니다.
-   **통일성 유지**: 프로젝트 전반에 걸쳐 일관된 스타일을 유지하기 위해 사전 정의된 `classDef`를 사용하며, 커스텀 색상은 사용하지 않습니다.

### 4.2. 표준 색상 팔레트 및 `classDef`

다크 테마에 최적화된 표준 색상 및 클래스입니다. 다이어그램 작성 시 노드의 의미에 맞는 클래스를 지정해야 합니다.

| 역할                    | 클래스명    | 색상 계열 | 배경색 (`fill`) | 테두리색 (`stroke`) | 글자색 (`color`) |
| :---------------------- | :---------- | :-------- | :-------------- | :------------------ | :--------------- |
| **기본 노드**           | `default`   | 회색      | `#444`          | `#888`              | `#ddd`           |
| **핵심/진입점**         | `primary`   | 파란색    | `#2E6E9E`       | `#1C4E7A`           | `#fff`           |
| **내부 컴포넌트/모듈**  | `component` | 청록색    | `#3A7D7C`       | `#2A6D6C`           | `#fff`           |
| **외부 시스템/API**     | `external`  | 보라색    | `#6C4E9A`       | `#4C2E7A`           | `#fff`           |
| **데이터베이스/저장소** | `db`        | 주황색    | `#A86D3A`       | `#884D1A`           | `#fff`           |
| **조건문/분기**         | `decision`  | 녹색      | `#028834`       | `#015F24`           | `#fff`           |
| **입력/출력**           | `io`        | 자주색    | `#8E44AD`       | `#6C3483`           | `#fff`           |
| **경고/오류**           | `warning`   | 붉은색    | `#994444`       | `#772222`           | `#fff`           |

### 4.3. 의미에 맞는 노드 모양 사용 (Semantic Shapes)

색상뿐만 아니라 노드의 모양을 통해서도 역할과 의미를 시각적으로 전달할 수 있습니다. 특정 역할에는 다음과 같은 표준 모양을 사용하는 것을 권장합니다.

| 역할                    | 모양        | Mermaid 문법 | 설명                                                                     |
| :---------------------- | :---------- | :----------- | :----------------------------------------------------------------------- |
| **시작/종료**           | 둥근 사각형 | `A([...])`   | 프로세스의 시작과 끝을 나타냅니다.                                       |
| **프로세스/컴포넌트**   | 사각형      | `B["..."]`   | 일반적인 단계나 컴포넌트를 나타냅니다.                                   |
| **조건문/분기**         | 마름모      | `C{"..."}`   | `if`문, `switch`문 등 코드의 분기가 발생하는 의사결정 지점을 나타냅니다. |
| **데이터베이스/저장소** | 실린더      | `D[("...")]` | 데이터가 저장되는 곳을 나타냅니다.                                       |
| **입력/출력**           | 평행사변형  | `E[/"..."]`  | 사용자 입력이나 데이터 출력 등 I/O 작업을 나타냅니다.                    |

### 4.4. 종합 적용 예시

아래 예시는 모든 표준 클래스를 사용하여, 각 스타일이 실제 다이어그램에서 어떻게 보이는지 한눈에 파악할 수 있도록 구성되었습니다.

-   **`classDef` 선언**: 다이어그램 상단에 모든 표준 스타일 클래스를 먼저 정의합니다.
-   **역할 명시**: 각 노드의 텍스트에 해당하는 역할을 명시하여, 색상과 역할을 직관적으로 연결할 수 있도록 합니다.

```mermaid
graph TD
    %% 1. 스타일 클래스 정의 (모든 클래스 포함)
    classDef default fill:#444,stroke:#888,color:#ddd
    classDef primary fill:#2E6E9E,stroke:#1C4E7A,color:#fff
    classDef component fill:#3A7D7C,stroke:#2A6D6C,color:#fff
    classDef external fill:#6C4E9A,stroke:#4C2E7A,color:#fff
    classDef db fill:#A86D3A,stroke:#884D1A,color:#fff
    classDef decision fill:#028834,stroke:#015F24,color:#fff
    classDef io fill:#8E44AD,stroke:#6C3483,color:#fff
    classDef warning fill:#994444,stroke:#772222,color:#fff

    %% 2. 노드 선언 (역할과 모양을 함께 명시)
    Start(["프로세스 시작 (Start)"]):::primary
    UserInput[/"사용자 입력 (I/O)"/]:::io
    MainProcess["핵심 로직 처리 (Process)"]:::component
    CheckCondition{"데이터 유효성 검사 (Decision)"}:::decision
    SubModule["내부 모듈 호출 (Process)"]:::component
    UserData[("사용자 DB 조회 (Database)")]:::db
    PaymentGateway["외부 API 호출 (External)"]:::external
    End(["프로세스 종료 (End)"]):::primary
    ErrorState["오류 처리 (Warning)"]:::warning

    %% 3. 관계 연결
    Start --> UserInput
    UserInput --> MainProcess
    MainProcess --> CheckCondition
    CheckCondition -- "Success" --> SubModule
    SubModule --> UserData
    UserData --> PaymentGateway
    PaymentGateway --> End
    CheckCondition -- "Fail" --> ErrorState
```

-   **표현하려는 관계는 무엇인가?**: '상위-하위' 관계인가, '동등한' 관계인가?
-   **공간 활용**: 세로로 긴 다이어그램은 `TD`가, 가로로 넓은 다이어그램은 `LR`이 유리할 수 있습니다.
